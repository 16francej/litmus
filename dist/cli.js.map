{"version":3,"sources":["../src/cli/index.ts","../src/cli/init.ts","../src/utils/logger.ts","../src/cli/spec.ts","../src/config/loader.ts","../src/config/schema.ts","../src/interview/interviewer.ts","../src/utils/claude.ts","../src/interview/codebase-reader.ts","../src/interview/prompts.ts","../src/scenarios/writer.ts","../src/interview/expansion.ts","../src/runner/scenario-runner.ts","../src/scenarios/loader.ts","../src/scenarios/parser.ts","../src/runner/translator.ts","../src/runner/executor.ts","../src/utils/dev-server.ts","../src/cli/verify.ts","../src/loop/ralph.ts","../src/loop/coding-agent.ts","../src/loop/circuit-breaker.ts","../src/cli/loop.ts"],"sourcesContent":["import { Command } from \"commander\";\nimport { initCommand } from \"./init.js\";\nimport { specCommand } from \"./spec.js\";\nimport { verifyCommand } from \"./verify.js\";\nimport { loopCommand } from \"./loop.js\";\n\nconst program = new Command();\n\nprogram\n  .name(\"litmus\")\n  .description(\n    \"Generate exhaustive behavioral scenarios and iterate until they all pass\"\n  )\n  .version(\"0.1.0\");\n\nprogram\n  .command(\"init\")\n  .description(\"Initialize litmus in your project\")\n  .action(initCommand);\n\nprogram\n  .command(\"spec\")\n  .description(\"Interview about a feature and generate scenarios\")\n  .argument(\"<description>\", \"High-level description of the feature\")\n  .option(\"-m, --model <model>\", \"Claude model to use\")\n  .action(specCommand);\n\nprogram\n  .command(\"verify\")\n  .description(\"Run all scenarios against the running app\")\n  .option(\"--headed\", \"Run browser in headed mode (visible)\")\n  .option(\"-f, --filter <pattern>\", \"Only run scenarios matching pattern\")\n  .action(verifyCommand);\n\nprogram\n  .command(\"loop\")\n  .description(\n    \"Run the ralph loop: code until all scenarios pass\"\n  )\n  .option(\n    \"-n, --max-iterations <n>\",\n    \"Maximum iterations before stopping\",\n    \"15\"\n  )\n  .option(\"--max-cost <dollars>\", \"Maximum cost in dollars\", \"5\")\n  .option(\"-m, --model <model>\", \"Claude model for coding agent\")\n  .action(loopCommand);\n\nprogram.parse();\n","import { existsSync, mkdirSync, writeFileSync, readFileSync } from \"fs\";\nimport { resolve, join } from \"path\";\nimport { log } from \"../utils/logger.js\";\n\nconst CONFIG_TEMPLATE = `import { defineConfig } from \"litmus\";\n\nexport default defineConfig({\n  // Required: where is your app?\n  baseUrl: \"http://localhost:3000\",\n\n  // Optional: command to start your dev server\n  // devCommand: \"npm run dev\",\n\n  // Optional: auth setup for scenarios that need a logged-in user\n  // auth: {\n  //   loginUrl: \"/login\",\n  //   testUser: { email: \"test@example.com\", password: \"password123\" },\n  // },\n\n  // Optional: command to seed test data before verification\n  // setup: \"npm run db:seed\",\n});\n`;\n\nconst EXAMPLE_SCENARIO = `---\npriority: high\ntype: happy-path\nconfidence: direct\n---\n\n# Example — Homepage loads successfully\n\n## Context\n- User is not logged in\n- No special data requirements\n\n## Steps\n1. Navigate to the homepage\n2. Wait for the page to fully load\n\n## Expected\n- Page title is visible\n- No console errors\n- Page loads within 3 seconds\n`;\n\nconst GITIGNORE_ENTRY = `\n# Litmus\n.litmus/\n`;\n\nexport async function initCommand(): Promise<void> {\n  const cwd = process.cwd();\n\n  log.heading(\"Initializing litmus...\");\n\n  // Create config file\n  const configPath = resolve(cwd, \"litmus.config.ts\");\n  if (existsSync(configPath)) {\n    log.warn(\"litmus.config.ts already exists, skipping\");\n  } else {\n    writeFileSync(configPath, CONFIG_TEMPLATE);\n    log.success(\"Created litmus.config.ts\");\n  }\n\n  // Create scenarios directory\n  const scenariosDir = resolve(cwd, \"specs/scenarios\");\n  mkdirSync(scenariosDir, { recursive: true });\n  log.success(\"Created specs/scenarios/\");\n\n  // Write example scenario\n  const examplePath = join(scenariosDir, \"example-homepage.md\");\n  if (!existsSync(examplePath)) {\n    writeFileSync(examplePath, EXAMPLE_SCENARIO);\n    log.success(\"Created example scenario: specs/scenarios/example-homepage.md\");\n  }\n\n  // Create .litmus directory for internal state\n  const litmusDir = resolve(cwd, \".litmus\");\n  mkdirSync(litmusDir, { recursive: true });\n  mkdirSync(join(litmusDir, \"failures\"), { recursive: true });\n\n  // Add to .gitignore\n  const gitignorePath = resolve(cwd, \".gitignore\");\n  if (existsSync(gitignorePath)) {\n    const gitignore = readFileSync(gitignorePath, \"utf-8\");\n    if (!gitignore.includes(\".litmus/\")) {\n      writeFileSync(gitignorePath, gitignore + GITIGNORE_ENTRY);\n      log.success(\"Added .litmus/ to .gitignore\");\n    }\n  } else {\n    writeFileSync(gitignorePath, GITIGNORE_ENTRY.trim() + \"\\n\");\n    log.success(\"Created .gitignore with .litmus/\");\n  }\n\n  log.heading(\"Done! Next steps:\");\n  log.info(\"1. Edit litmus.config.ts with your app's URL and dev command\");\n  log.info(\n    '2. Run `litmus spec \"describe your feature\"` to generate scenarios'\n  );\n  log.info(\"3. Review and edit the generated scenario files in specs/scenarios/\");\n  log.info(\"4. Run `litmus loop` to implement and verify\");\n}\n","import chalk from \"chalk\";\nimport ora, { type Ora } from \"ora\";\n\nexport const log = {\n  info: (msg: string) => console.log(chalk.blue(\"info\") + \" \" + msg),\n  success: (msg: string) => console.log(chalk.green(\"pass\") + \" \" + msg),\n  fail: (msg: string) => console.log(chalk.red(\"fail\") + \" \" + msg),\n  warn: (msg: string) => console.log(chalk.yellow(\"warn\") + \" \" + msg),\n  dim: (msg: string) => console.log(chalk.dim(msg)),\n  heading: (msg: string) => console.log(\"\\n\" + chalk.bold(msg)),\n  scenario: (name: string, passed: boolean) =>\n    console.log(\n      `  ${passed ? chalk.green(\"✓\") : chalk.red(\"✗\")} ${name}`\n    ),\n};\n\nexport function spinner(text: string): Ora {\n  return ora({ text, color: \"cyan\" }).start();\n}\n","import { resolve } from \"path\";\nimport { loadConfig } from \"../config/loader.js\";\nimport { runInterview } from \"../interview/interviewer.js\";\nimport { expandScenarios } from \"../interview/expansion.js\";\nimport {\n  readCodebaseContext,\n  formatCodebaseContext,\n} from \"../interview/codebase-reader.js\";\nimport { log } from \"../utils/logger.js\";\n\nexport async function specCommand(\n  description: string,\n  options: { model?: string }\n): Promise<void> {\n  const cwd = process.cwd();\n\n  let config;\n  try {\n    config = await loadConfig(cwd);\n  } catch {\n    log.warn(\"No litmus config found. Using defaults.\");\n    config = {\n      baseUrl: \"http://localhost:3000\",\n      scenariosDir: \"specs/scenarios\",\n      model: \"claude-sonnet-4-5-20250929\",\n      loop: { maxIterations: 15, maxCost: 5, model: \"claude-sonnet-4-5-20250929\" },\n    };\n  }\n\n  const model = options.model ?? config.model;\n\n  // Run the interview\n  const { requirements } = await runInterview(description, {\n    cwd,\n    model,\n  });\n\n  // Get codebase context for expansion\n  const codebaseCtx = readCodebaseContext(cwd);\n  const contextStr = formatCodebaseContext(codebaseCtx);\n\n  // Expand into scenarios\n  const scenariosDir = resolve(cwd, config.scenariosDir);\n  const result = await expandScenarios(requirements, contextStr, {\n    scenariosDir,\n    model,\n  });\n\n  // Print summary\n  log.heading(\"Scenario Summary\");\n  log.info(`Total: ${result.total} scenarios`);\n\n  log.heading(\"By Category:\");\n  for (const [cat, count] of Object.entries(result.byCategory)) {\n    log.info(`  ${cat}: ${count}`);\n  }\n\n  log.heading(\"By Confidence:\");\n  for (const [conf, count] of Object.entries(result.byConfidence)) {\n    log.info(`  ${conf}: ${count}`);\n  }\n\n  console.log(\"\");\n  log.info(\n    `Scenarios written to ${config.scenariosDir}/`\n  );\n  log.info(\"Review and edit these files, then run: litmus loop\");\n}\n","import { readFileSync, existsSync, writeFileSync, unlinkSync } from \"fs\";\nimport { resolve, join, dirname } from \"path\";\nimport { pathToFileURL } from \"url\";\nimport { configSchema, type ResolvedConfig } from \"./schema.js\";\nimport { spawnSync } from \"child_process\";\nimport { tmpdir } from \"os\";\nimport { randomUUID } from \"crypto\";\n\nconst CONFIG_FILENAMES = [\n  \"litmus.config.ts\",\n  \"litmus.config.js\",\n  \"litmus.config.mjs\",\n];\n\nexport async function loadConfig(cwd: string): Promise<ResolvedConfig> {\n  let configPath: string | undefined;\n\n  for (const filename of CONFIG_FILENAMES) {\n    const candidate = resolve(cwd, filename);\n    if (existsSync(candidate)) {\n      configPath = candidate;\n      break;\n    }\n  }\n\n  if (!configPath) {\n    throw new Error(\n      `No litmus config file found. Run \\`litmus init\\` to create one.`\n    );\n  }\n\n  let rawConfig: Record<string, unknown>;\n\n  if (configPath.endsWith(\".ts\")) {\n    rawConfig = await loadTsConfig(configPath);\n  } else {\n    const mod = await import(pathToFileURL(configPath).href);\n    rawConfig = mod.default ?? mod;\n  }\n\n  // Extract the auth setup function before Zod validation (Zod can't validate functions)\n  const authSetup =\n    typeof rawConfig?.auth === \"object\" &&\n    rawConfig.auth !== null &&\n    \"setup\" in rawConfig.auth &&\n    typeof (rawConfig.auth as Record<string, unknown>).setup === \"function\"\n      ? ((rawConfig.auth as Record<string, unknown>).setup as ResolvedConfig[\"authSetup\"])\n      : undefined;\n\n  // Remove the function from the raw config before Zod validation\n  if (authSetup && typeof rawConfig.auth === \"object\" && rawConfig.auth !== null) {\n    const authCopy = { ...rawConfig.auth } as Record<string, unknown>;\n    delete authCopy.setup;\n    rawConfig = { ...rawConfig, auth: authCopy };\n  }\n\n  const parsed = configSchema.parse(rawConfig);\n\n  return {\n    ...parsed,\n    authSetup,\n  };\n}\n\n/**\n * Load a TypeScript config file.\n * Strategy: strip the TS-specific syntax and write a temporary .mjs file, then import it.\n */\nasync function loadTsConfig(\n  configPath: string\n): Promise<Record<string, unknown>> {\n  const content = readFileSync(configPath, \"utf-8\");\n\n  // Strip TypeScript-specific syntax to create a plain JS version\n  const jsContent = content\n    // Remove import { defineConfig } from \"litmus\" — replace with identity function\n    .replace(\n      /import\\s*\\{[^}]*\\}\\s*from\\s*[\"'][^\"']*[\"'];?\\s*/g,\n      \"const defineConfig = (c) => c;\\n\"\n    )\n    // Remove type annotations (simple cases)\n    .replace(/:\\s*\\w+(\\[\\])?\\s*(?=[,;=)\\n])/g, \"\")\n    // Convert export default to module.exports for compatibility\n    .replace(/export\\s+default\\s+/, \"export default \");\n\n  // Write to a temp .mjs file and import it\n  const tmpFile = join(tmpdir(), `litmus-config-${randomUUID()}.mjs`);\n  writeFileSync(tmpFile, jsContent, \"utf-8\");\n\n  try {\n    const mod = await import(pathToFileURL(tmpFile).href);\n    return mod.default ?? mod;\n  } finally {\n    try {\n      unlinkSync(tmpFile);\n    } catch {\n      // ignore cleanup errors\n    }\n  }\n}\n","import { z } from \"zod\";\n\nexport const authConfigSchema = z.object({\n  loginUrl: z.string().optional(),\n  testUser: z\n    .object({\n      email: z.string(),\n      password: z.string(),\n    })\n    .optional(),\n  // Custom setup function is handled at runtime, not validated by Zod\n});\n\nexport const loopConfigSchema = z.object({\n  maxIterations: z.number().default(15),\n  maxCost: z.number().default(5),\n  model: z.string().default(\"claude-sonnet-4-5-20250929\"),\n});\n\nexport const configSchema = z.object({\n  baseUrl: z.string().url(),\n  devCommand: z.string().optional(),\n  auth: authConfigSchema.optional(),\n  setup: z.string().optional(),\n  model: z.string().default(\"claude-sonnet-4-5-20250929\"),\n  loop: loopConfigSchema.optional().default({}),\n  scenariosDir: z.string().default(\"specs/scenarios\"),\n});\n\nexport type LitmusConfig = z.infer<typeof configSchema>;\n\nexport type AuthSetupFn = (page: import(\"playwright\").Page) => Promise<void>;\n\nexport interface ResolvedConfig extends LitmusConfig {\n  authSetup?: AuthSetupFn;\n}\n","import { createInterface } from \"readline\";\nimport { chatStream, type Message } from \"../utils/claude.js\";\nimport {\n  readCodebaseContext,\n  formatCodebaseContext,\n} from \"./codebase-reader.js\";\nimport { log, spinner } from \"../utils/logger.js\";\nimport { INTERVIEW_PROMPT } from \"./prompts.js\";\n\nfunction ask(rl: ReturnType<typeof createInterface>, prompt: string): Promise<string> {\n  return new Promise((resolve) => {\n    rl.question(prompt, (answer) => resolve(answer));\n  });\n}\n\nexport interface InterviewResult {\n  requirements: string;\n  conversationHistory: Message[];\n}\n\n/**\n * Run the specification interview. Conducts a multi-turn conversation\n * with the developer to understand the feature requirements.\n */\nexport async function runInterview(\n  featureDescription: string,\n  options: { cwd: string; model?: string }\n): Promise<InterviewResult> {\n  const s = spinner(\"Reading codebase...\");\n  const codebaseContext = readCodebaseContext(options.cwd);\n  s.succeed(\"Codebase analyzed\");\n\n  const contextStr = formatCodebaseContext(codebaseContext);\n  if (contextStr) {\n    log.dim(\n      `Found: ${codebaseContext.stack.join(\", \") || \"unknown stack\"}, ${codebaseContext.routes.length} routes`\n    );\n  }\n\n  const systemPrompt = `${INTERVIEW_PROMPT}\\n\\n## Codebase Context\\n\\n${contextStr}`;\n\n  const messages: Message[] = [\n    {\n      role: \"user\",\n      content: `I want to build the following feature: ${featureDescription}\\n\\nPlease interview me to understand all the requirements.`,\n    },\n  ];\n\n  const rl = createInterface({\n    input: process.stdin,\n    output: process.stdout,\n  });\n\n  const model = options.model ?? \"claude-sonnet-4-5-20250929\";\n\n  try {\n    while (true) {\n      // Get Claude's response (streamed to terminal)\n      process.stdout.write(\"\\n\");\n      let fullResponse = \"\";\n\n      for await (const chunk of chatStream(messages, {\n        system: systemPrompt,\n        model,\n      })) {\n        process.stdout.write(chunk);\n        fullResponse += chunk;\n      }\n\n      process.stdout.write(\"\\n\");\n\n      messages.push({ role: \"assistant\", content: fullResponse });\n\n      // Check if the response contains the requirements summary\n      if (fullResponse.includes(\"```requirements\")) {\n        const requirementsMatch = fullResponse.match(\n          /```requirements\\n([\\s\\S]*?)\\n```/\n        );\n        if (requirementsMatch) {\n          log.heading(\"Requirements captured. Generating scenarios...\");\n          rl.close();\n          return {\n            requirements: requirementsMatch[1],\n            conversationHistory: messages,\n          };\n        }\n      }\n\n      // Get developer input\n      const userInput = await ask(rl, \"\\n> \");\n\n      if (\n        userInput.toLowerCase() === \"done\" ||\n        userInput.toLowerCase() === \"generate\"\n      ) {\n        messages.push({\n          role: \"user\",\n          content:\n            \"I think that covers it. Please generate the requirements summary now.\",\n        });\n      } else {\n        messages.push({ role: \"user\", content: userInput });\n      }\n    }\n  } finally {\n    rl.close();\n  }\n}\n","import Anthropic from \"@anthropic-ai/sdk\";\n\nlet client: Anthropic | undefined;\n\nexport function getClient(): Anthropic {\n  if (!client) {\n    const apiKey = process.env.ANTHROPIC_API_KEY;\n    if (!apiKey) {\n      throw new Error(\n        \"ANTHROPIC_API_KEY environment variable is required. Set it with: export ANTHROPIC_API_KEY=sk-...\"\n      );\n    }\n    client = new Anthropic({ apiKey });\n  }\n  return client;\n}\n\nexport interface Message {\n  role: \"user\" | \"assistant\";\n  content: string;\n}\n\nexport async function chat(\n  messages: Message[],\n  options: {\n    system?: string;\n    model?: string;\n    maxTokens?: number;\n  } = {}\n): Promise<string> {\n  const anthropic = getClient();\n  const response = await anthropic.messages.create({\n    model: options.model ?? \"claude-sonnet-4-5-20250929\",\n    max_tokens: options.maxTokens ?? 8192,\n    system: options.system,\n    messages,\n  });\n\n  const textBlock = response.content.find((block) => block.type === \"text\");\n  return textBlock?.text ?? \"\";\n}\n\nexport async function* chatStream(\n  messages: Message[],\n  options: {\n    system?: string;\n    model?: string;\n    maxTokens?: number;\n  } = {}\n): AsyncGenerator<string> {\n  const anthropic = getClient();\n\n  const stream = anthropic.messages.stream({\n    model: options.model ?? \"claude-sonnet-4-5-20250929\",\n    max_tokens: options.maxTokens ?? 8192,\n    system: options.system,\n    messages,\n  });\n\n  for await (const event of stream) {\n    if (\n      event.type === \"content_block_delta\" &&\n      event.delta.type === \"text_delta\"\n    ) {\n      yield event.delta.text;\n    }\n  }\n}\n\n/**\n * Estimate token cost in dollars for Claude Sonnet.\n * Input: $3/MTok, Output: $15/MTok (approximate)\n */\nexport function estimateCost(\n  inputTokens: number,\n  outputTokens: number\n): number {\n  return (inputTokens / 1_000_000) * 3 + (outputTokens / 1_000_000) * 15;\n}\n","import { existsSync, readFileSync, readdirSync, statSync } from \"fs\";\nimport { join, extname } from \"path\";\n\nexport interface CodebaseContext {\n  stack: string[];\n  routes: string[];\n  schema: string[];\n  components: string[];\n  existingTests: string[];\n  packageInfo: Record<string, unknown> | null;\n}\n\n/**\n * Scan the project to understand the codebase and provide context for the interview.\n */\nexport function readCodebaseContext(cwd: string): CodebaseContext {\n  const context: CodebaseContext = {\n    stack: [],\n    routes: [],\n    schema: [],\n    components: [],\n    existingTests: [],\n    packageInfo: null,\n  };\n\n  // Read package.json\n  const pkgPath = join(cwd, \"package.json\");\n  if (existsSync(pkgPath)) {\n    try {\n      context.packageInfo = JSON.parse(readFileSync(pkgPath, \"utf-8\"));\n      context.stack.push(...detectStack(context.packageInfo as Record<string, unknown>));\n    } catch {\n      // ignore\n    }\n  }\n\n  // Detect Next.js app routes\n  const appDir = join(cwd, \"app\");\n  const srcAppDir = join(cwd, \"src\", \"app\");\n  const pagesDir = join(cwd, \"pages\");\n  const srcPagesDir = join(cwd, \"src\", \"pages\");\n\n  for (const dir of [appDir, srcAppDir]) {\n    if (existsSync(dir)) {\n      context.routes.push(...findNextAppRoutes(dir, dir));\n    }\n  }\n\n  for (const dir of [pagesDir, srcPagesDir]) {\n    if (existsSync(dir)) {\n      context.routes.push(...findNextPageRoutes(dir, dir));\n    }\n  }\n\n  // Detect Prisma schema\n  const prismaPath = join(cwd, \"prisma\", \"schema.prisma\");\n  if (existsSync(prismaPath)) {\n    const schema = readFileSync(prismaPath, \"utf-8\");\n    context.schema.push(truncate(schema, 3000));\n    context.stack.push(\"Prisma ORM\");\n  }\n\n  // Detect Drizzle schema\n  const drizzleFiles = findFiles(cwd, (f) =>\n    f.includes(\"schema\") && (f.endsWith(\".ts\") || f.endsWith(\".js\")) && f.includes(\"drizzle\")\n  );\n  for (const f of drizzleFiles.slice(0, 3)) {\n    context.schema.push(truncate(readFileSync(f, \"utf-8\"), 2000));\n    if (!context.stack.includes(\"Drizzle ORM\")) context.stack.push(\"Drizzle ORM\");\n  }\n\n  // Find components\n  const componentDirs = [\"components\", \"src/components\", \"app/components\"];\n  for (const dir of componentDirs) {\n    const fullDir = join(cwd, dir);\n    if (existsSync(fullDir)) {\n      context.components.push(\n        ...listFilesShallow(fullDir).map((f) => f.replace(cwd + \"/\", \"\"))\n      );\n    }\n  }\n\n  // Find existing tests\n  const testPatterns = [\"__tests__\", \"tests\", \"test\", \"spec\", \"*.test.*\", \"*.spec.*\"];\n  const testFiles = findFiles(cwd, (f) => {\n    const lower = f.toLowerCase();\n    return (\n      (lower.includes(\".test.\") || lower.includes(\".spec.\") || lower.includes(\"__tests__\")) &&\n      !lower.includes(\"node_modules\")\n    );\n  });\n  context.existingTests = testFiles.slice(0, 20).map((f) => f.replace(cwd + \"/\", \"\"));\n\n  return context;\n}\n\nfunction detectStack(pkg: Record<string, unknown>): string[] {\n  const stack: string[] = [];\n  const deps = {\n    ...(pkg.dependencies as Record<string, string> ?? {}),\n    ...(pkg.devDependencies as Record<string, string> ?? {}),\n  };\n\n  if (deps[\"next\"]) stack.push(`Next.js ${deps[\"next\"]}`);\n  if (deps[\"react\"]) stack.push(\"React\");\n  if (deps[\"vue\"]) stack.push(\"Vue\");\n  if (deps[\"svelte\"] || deps[\"@sveltejs/kit\"]) stack.push(\"Svelte/SvelteKit\");\n  if (deps[\"express\"]) stack.push(\"Express\");\n  if (deps[\"@supabase/supabase-js\"]) stack.push(\"Supabase\");\n  if (deps[\"firebase\"]) stack.push(\"Firebase\");\n  if (deps[\"stripe\"]) stack.push(\"Stripe\");\n  if (deps[\"@auth/core\"] || deps[\"next-auth\"]) stack.push(\"NextAuth/Auth.js\");\n  if (deps[\"@clerk/nextjs\"]) stack.push(\"Clerk Auth\");\n  if (deps[\"tailwindcss\"]) stack.push(\"Tailwind CSS\");\n  if (deps[\"prisma\"] || deps[\"@prisma/client\"]) stack.push(\"Prisma\");\n  if (deps[\"drizzle-orm\"]) stack.push(\"Drizzle ORM\");\n\n  return stack;\n}\n\nfunction findNextAppRoutes(dir: string, baseDir: string): string[] {\n  const routes: string[] = [];\n  try {\n    for (const entry of readdirSync(dir)) {\n      const fullPath = join(dir, entry);\n      if (statSync(fullPath).isDirectory()) {\n        if (!entry.startsWith(\"_\") && !entry.startsWith(\".\")) {\n          routes.push(...findNextAppRoutes(fullPath, baseDir));\n        }\n      } else if (entry.startsWith(\"page.\")) {\n        const route = dir.replace(baseDir, \"\").replace(/\\\\/g, \"/\") || \"/\";\n        routes.push(route);\n      }\n    }\n  } catch {\n    // ignore\n  }\n  return routes;\n}\n\nfunction findNextPageRoutes(dir: string, baseDir: string): string[] {\n  const routes: string[] = [];\n  try {\n    for (const entry of readdirSync(dir)) {\n      const fullPath = join(dir, entry);\n      if (statSync(fullPath).isDirectory()) {\n        routes.push(...findNextPageRoutes(fullPath, baseDir));\n      } else if (/\\.(tsx?|jsx?)$/.test(entry) && !entry.startsWith(\"_\")) {\n        const route = fullPath\n          .replace(baseDir, \"\")\n          .replace(/\\\\/g, \"/\")\n          .replace(/\\.(tsx?|jsx?)$/, \"\")\n          .replace(/\\/index$/, \"/\");\n        routes.push(route);\n      }\n    }\n  } catch {\n    // ignore\n  }\n  return routes;\n}\n\nfunction findFiles(\n  dir: string,\n  predicate: (filePath: string) => boolean,\n  maxDepth: number = 4,\n  currentDepth: number = 0\n): string[] {\n  if (currentDepth >= maxDepth) return [];\n  const results: string[] = [];\n\n  try {\n    for (const entry of readdirSync(dir)) {\n      if (entry === \"node_modules\" || entry === \".git\" || entry === \".next\" || entry === \"dist\") {\n        continue;\n      }\n      const fullPath = join(dir, entry);\n      const stat = statSync(fullPath);\n      if (stat.isDirectory()) {\n        results.push(...findFiles(fullPath, predicate, maxDepth, currentDepth + 1));\n      } else if (predicate(fullPath)) {\n        results.push(fullPath);\n      }\n    }\n  } catch {\n    // ignore\n  }\n\n  return results;\n}\n\nfunction listFilesShallow(dir: string): string[] {\n  try {\n    return readdirSync(dir)\n      .map((f) => join(dir, f))\n      .filter((f) => statSync(f).isFile())\n      .slice(0, 30);\n  } catch {\n    return [];\n  }\n}\n\nfunction truncate(text: string, maxLength: number): string {\n  if (text.length <= maxLength) return text;\n  return text.slice(0, maxLength) + \"\\n... (truncated)\";\n}\n\n/**\n * Format the codebase context into a string for the LLM system prompt.\n */\nexport function formatCodebaseContext(ctx: CodebaseContext): string {\n  const parts: string[] = [];\n\n  if (ctx.stack.length > 0) {\n    parts.push(`**Tech Stack:** ${ctx.stack.join(\", \")}`);\n  }\n\n  if (ctx.routes.length > 0) {\n    parts.push(`**Routes:** ${ctx.routes.join(\", \")}`);\n  }\n\n  if (ctx.components.length > 0) {\n    parts.push(`**Components:** ${ctx.components.slice(0, 15).join(\", \")}`);\n  }\n\n  if (ctx.schema.length > 0) {\n    parts.push(`**Database Schema:**\\n\\`\\`\\`\\n${ctx.schema.join(\"\\n\\n\")}\\n\\`\\`\\``);\n  }\n\n  if (ctx.existingTests.length > 0) {\n    parts.push(`**Existing Tests:** ${ctx.existingTests.join(\", \")}`);\n  }\n\n  return parts.join(\"\\n\\n\");\n}\n","export const INTERVIEW_PROMPT = `You are a product specification expert helping a developer define behavioral scenarios for a feature.\n\nYour job is to conduct a structured interview to extract all the information needed to generate exhaustive test scenarios. You need to understand:\n\n1. **Intent** — What is being built and why\n2. **User workflows** — Step-by-step what users do\n3. **Edge cases** — What happens with unusual inputs, states, or timing\n4. **Failure modes** — What happens when things go wrong\n5. **Business rules** — Limits, permissions, restrictions\n6. **Operational concerns** — Performance, scale, reliability expectations\n\n## Interview Guidelines\n\n- Ask one focused question at a time\n- Build on previous answers — don't repeat what you already know\n- Use the codebase context to ask informed questions (e.g., \"I see you have a User model with an email field — should email changes require verification?\")\n- When the developer gives a brief answer, probe deeper on areas that commonly cause bugs\n- After 5-8 exchanges, check if they feel the feature is well-defined enough to generate scenarios\n- Keep the conversation natural and efficient — don't ask obvious questions\n\n## When you have enough information\n\nWhen you believe you have enough context, respond with a structured summary in this exact format:\n\n\\`\\`\\`requirements\nFEATURE: <feature name>\nDESCRIPTION: <1-2 sentence summary>\n\nWORKFLOWS:\n- <workflow 1>\n- <workflow 2>\n\nEDGE_CASES:\n- <edge case 1>\n- <edge case 2>\n\nFAILURE_MODES:\n- <failure mode 1>\n- <failure mode 2>\n\nBUSINESS_RULES:\n- <rule 1>\n- <rule 2>\n\nOPERATIONAL:\n- <concern 1>\n- <concern 2>\n\\`\\`\\`\n\nOnly output this summary when the developer confirms they're ready to generate scenarios. Before that, keep interviewing.`;\n\nexport const EXPANSION_PROMPT = `You are a scenario generation engine. Given a requirements summary and codebase context, generate an exhaustive set of behavioral scenarios.\n\n## Generation Layers\n\n**Layer 1 — Direct scenarios:** Straight translations of the stated requirements. Happy paths, explicit edge cases, stated failure modes.\n\n**Layer 2 — Combinatorial expansion:** Expand each scenario across variable dimensions:\n- User states (new, active, expired, suspended, admin, guest)\n- Input variations (valid, empty, malformed, boundary values, unicode, extremely long)\n- Timing conditions (mid-operation, concurrent, rapid succession)\n- Data conditions (first item, many items, at limit, zero results)\n\n**Layer 3 — Cross-cutting concerns:** Apply universally:\n- Authentication states (logged out, expired session, wrong permissions)\n- Empty and loading states\n- Network/timeout handling\n- Idempotency (double-click, double-submit, back button after submit)\n- Accessibility basics (keyboard navigation, screen reader labels)\n\n**Layer 4 — Inferred scenarios:** Speculative edge cases based on common failure patterns in similar features. Flag these as confidence: inferred.\n\n## Output Format\n\nReturn a JSON array of scenario objects. Each object must have:\n\n\\`\\`\\`json\n[\n  {\n    \"name\": \"Descriptive scenario name\",\n    \"category\": \"category-slug\",\n    \"context\": [\"precondition 1\", \"precondition 2\"],\n    \"steps\": [\"Step 1 description\", \"Step 2 description\"],\n    \"expected\": [\"Expected outcome 1\", \"Expected outcome 2\"],\n    \"metadata\": {\n      \"priority\": \"high|medium|low\",\n      \"type\": \"happy-path|edge-case|failure-mode|infrastructure\",\n      \"confidence\": \"direct|expanded|inferred\"\n    }\n  }\n]\n\\`\\`\\`\n\n## Rules\n\n- Generate at MINIMUM 30 scenarios. Aim for 40-80 for a typical feature.\n- Every happy path should have corresponding edge cases and failure modes.\n- Group scenarios logically by category (e.g., \"auth\", \"checkout\", \"profile\").\n- Steps should be written as user-facing actions (\"Click the submit button\", \"Enter email address\"), not code-level instructions.\n- Expected outcomes should be observable in the browser (\"User sees success message\", \"Form shows validation error\").\n- Be specific: \"Enter 'test@example.com' in the email field\" not \"Enter an email\".\n- Mark inferred scenarios clearly so the developer can review them.`;\n","import { mkdirSync, writeFileSync } from \"fs\";\nimport { dirname, join } from \"path\";\nimport type { Scenario, ScenarioMetadata } from \"./types.js\";\n\nexport interface ScenarioInput {\n  name: string;\n  category: string;\n  context: string[];\n  steps: string[];\n  expected: string[];\n  metadata: ScenarioMetadata;\n}\n\nexport function writeScenarioFile(\n  scenario: ScenarioInput,\n  scenariosDir: string\n): string {\n  const content = formatScenario(scenario);\n  const fileName = slugify(scenario.name) + \".md\";\n  const filePath = join(scenariosDir, scenario.category, fileName);\n\n  mkdirSync(dirname(filePath), { recursive: true });\n  writeFileSync(filePath, content, \"utf-8\");\n\n  return filePath;\n}\n\nexport function formatScenario(scenario: ScenarioInput): string {\n  const lines: string[] = [];\n\n  // Frontmatter\n  lines.push(\"---\");\n  lines.push(`priority: ${scenario.metadata.priority}`);\n  lines.push(`type: ${scenario.metadata.type}`);\n  lines.push(`confidence: ${scenario.metadata.confidence}`);\n  lines.push(\"---\");\n  lines.push(\"\");\n\n  // Heading\n  lines.push(`# ${capitalize(scenario.category)} — ${scenario.name}`);\n  lines.push(\"\");\n\n  // Context\n  lines.push(\"## Context\");\n  for (const item of scenario.context) {\n    lines.push(`- ${item}`);\n  }\n  lines.push(\"\");\n\n  // Steps\n  lines.push(\"## Steps\");\n  scenario.steps.forEach((step, i) => {\n    lines.push(`${i + 1}. ${step}`);\n  });\n  lines.push(\"\");\n\n  // Expected\n  lines.push(\"## Expected\");\n  for (const item of scenario.expected) {\n    lines.push(`- ${item}`);\n  }\n  lines.push(\"\");\n\n  return lines.join(\"\\n\");\n}\n\nfunction slugify(text: string): string {\n  return text\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, \"-\")\n    .replace(/^-|-$/g, \"\");\n}\n\nfunction capitalize(text: string): string {\n  return text.charAt(0).toUpperCase() + text.slice(1);\n}\n","import { chat } from \"../utils/claude.js\";\nimport { log, spinner } from \"../utils/logger.js\";\nimport { writeScenarioFile, type ScenarioInput } from \"../scenarios/writer.js\";\nimport type { ScenarioMetadata } from \"../scenarios/types.js\";\nimport { EXPANSION_PROMPT } from \"./prompts.js\";\n\ninterface RawScenario {\n  name: string;\n  category: string;\n  context: string[];\n  steps: string[];\n  expected: string[];\n  metadata: ScenarioMetadata;\n}\n\n/**\n * Generate exhaustive scenarios from a requirements summary using Claude.\n * Writes scenario files to the scenarios directory.\n */\nexport async function expandScenarios(\n  requirements: string,\n  codebaseContext: string,\n  options: {\n    scenariosDir: string;\n    model?: string;\n  }\n): Promise<{ total: number; byCategory: Record<string, number>; byConfidence: Record<string, number> }> {\n  const s = spinner(\"Generating scenarios...\");\n\n  const response = await chat(\n    [\n      {\n        role: \"user\",\n        content: `## Requirements\\n\\n${requirements}\\n\\n## Codebase Context\\n\\n${codebaseContext}\\n\\nGenerate the exhaustive scenario set as a JSON array. Return ONLY the JSON array, no other text.`,\n      },\n    ],\n    {\n      system: EXPANSION_PROMPT,\n      model: options.model ?? \"claude-sonnet-4-5-20250929\",\n      maxTokens: 16384,\n    }\n  );\n\n  s.text = \"Parsing scenarios...\";\n\n  // Extract JSON from response (handle potential markdown code blocks)\n  let jsonStr = response.trim();\n  const jsonMatch = jsonStr.match(/```(?:json)?\\s*\\n?([\\s\\S]*?)\\n?```/);\n  if (jsonMatch) {\n    jsonStr = jsonMatch[1].trim();\n  }\n\n  let scenarios: RawScenario[];\n  try {\n    scenarios = JSON.parse(jsonStr);\n  } catch {\n    s.fail(\"Failed to parse generated scenarios\");\n    throw new Error(\n      `Failed to parse scenario JSON from Claude response. Raw response:\\n${response.slice(0, 500)}`\n    );\n  }\n\n  if (!Array.isArray(scenarios) || scenarios.length === 0) {\n    s.fail(\"No scenarios generated\");\n    throw new Error(\"Claude returned an empty or invalid scenario array\");\n  }\n\n  s.text = `Writing ${scenarios.length} scenario files...`;\n\n  const byCategory: Record<string, number> = {};\n  const byConfidence: Record<string, number> = {};\n\n  for (const scenario of scenarios) {\n    const input: ScenarioInput = {\n      name: scenario.name,\n      category: scenario.category,\n      context: scenario.context ?? [],\n      steps: scenario.steps ?? [],\n      expected: scenario.expected ?? [],\n      metadata: {\n        priority: scenario.metadata?.priority ?? \"medium\",\n        type: scenario.metadata?.type ?? \"happy-path\",\n        confidence: scenario.metadata?.confidence ?? \"expanded\",\n      },\n    };\n\n    writeScenarioFile(input, options.scenariosDir);\n\n    byCategory[input.category] = (byCategory[input.category] ?? 0) + 1;\n    byConfidence[input.metadata.confidence] =\n      (byConfidence[input.metadata.confidence] ?? 0) + 1;\n  }\n\n  s.succeed(`Generated ${scenarios.length} scenarios`);\n\n  return {\n    total: scenarios.length,\n    byCategory,\n    byConfidence,\n  };\n}\n","import { resolve } from \"path\";\nimport { loadAllScenarios } from \"../scenarios/loader.js\";\nimport { translateScenario } from \"./translator.js\";\nimport { executeScenario, ensureBrowser, closeBrowser } from \"./executor.js\";\nimport { log, spinner } from \"../utils/logger.js\";\nimport type { Scenario, VerificationResult, VerificationSummary } from \"../scenarios/types.js\";\nimport type { ResolvedConfig } from \"../config/schema.js\";\nimport { ensureDevServer, stopDevServer } from \"../utils/dev-server.js\";\nimport { execSync } from \"child_process\";\n\nexport interface RunnerOptions {\n  headed?: boolean;\n  filter?: string;\n  model?: string;\n}\n\n/**\n * Run all scenarios against the live application.\n */\nexport async function runAllScenarios(\n  config: ResolvedConfig,\n  options: RunnerOptions = {}\n): Promise<VerificationSummary> {\n  const start = Date.now();\n  const cwd = process.cwd();\n  const scenariosDir = resolve(cwd, config.scenariosDir);\n  const screenshotDir = resolve(cwd, \".litmus\", \"failures\");\n\n  // Load scenarios\n  let scenarios = loadAllScenarios(scenariosDir);\n  if (scenarios.length === 0) {\n    throw new Error(\n      `No scenarios found in ${config.scenariosDir}/. Run \\`litmus spec\\` to generate some.`\n    );\n  }\n\n  // Apply filter if provided\n  if (options.filter) {\n    const pattern = new RegExp(options.filter, \"i\");\n    scenarios = scenarios.filter(\n      (s) => pattern.test(s.name) || pattern.test(s.category) || pattern.test(s.filePath)\n    );\n    if (scenarios.length === 0) {\n      throw new Error(`No scenarios match filter \"${options.filter}\"`);\n    }\n  }\n\n  log.info(`Found ${scenarios.length} scenarios`);\n\n  // Run setup command if configured\n  if (config.setup) {\n    const s = spinner(`Running setup: ${config.setup}`);\n    try {\n      execSync(config.setup, { cwd, stdio: \"pipe\" });\n      s.succeed(\"Setup complete\");\n    } catch (error) {\n      s.fail(\"Setup failed\");\n      throw error;\n    }\n  }\n\n  // Ensure dev server is running\n  const s = spinner(`Checking server at ${config.baseUrl}...`);\n  try {\n    await ensureDevServer(config.baseUrl, config.devCommand, cwd);\n    s.succeed(`Server ready at ${config.baseUrl}`);\n  } catch (error) {\n    s.fail(\"Server not available\");\n    throw error;\n  }\n\n  // Run scenarios\n  const results: VerificationResult[] = [];\n  const model = options.model ?? config.model;\n\n  log.heading(\"Running scenarios\\n\");\n\n  for (let i = 0; i < scenarios.length; i++) {\n    const scenario = scenarios[i];\n    const prefix = `[${i + 1}/${scenarios.length}]`;\n\n    try {\n      // Translate scenario to Playwright actions\n      const actions = await translateScenario(scenario, config.baseUrl, model);\n\n      // Execute the actions\n      const result = await executeScenario(scenario, actions, {\n        baseUrl: config.baseUrl,\n        headed: options.headed,\n        screenshotDir,\n      });\n\n      results.push(result);\n      log.scenario(`${prefix} ${scenario.category}/${scenario.name}`, result.passed);\n\n      if (!result.passed && result.actual) {\n        log.dim(`      ${result.actual.slice(0, 120)}`);\n      }\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      results.push({\n        scenario,\n        passed: false,\n        stepResults: [],\n        consoleLogs: [],\n        actual: errorMsg,\n        duration: 0,\n      });\n      log.scenario(`${prefix} ${scenario.category}/${scenario.name}`, false);\n      log.dim(`      ${errorMsg.slice(0, 120)}`);\n    }\n  }\n\n  // Close browser\n  await closeBrowser();\n\n  const summary: VerificationSummary = {\n    total: results.length,\n    passed: results.filter((r) => r.passed).length,\n    failed: results.filter((r) => !r.passed).length,\n    results,\n    duration: Date.now() - start,\n  };\n\n  return summary;\n}\n\n/**\n * Format a verification summary for terminal display.\n */\nexport function printSummary(summary: VerificationSummary): void {\n  const { total, passed, failed, duration } = summary;\n\n  log.heading(\"Results\");\n\n  if (failed === 0) {\n    log.success(`All ${total} scenarios passing`);\n  } else {\n    log.fail(`${failed}/${total} scenarios failed`);\n\n    log.heading(\"Failures:\");\n    for (const result of summary.results.filter((r) => !r.passed)) {\n      console.log(\"\");\n      log.fail(`${result.scenario.category}/${result.scenario.name}`);\n      if (result.failedStep) {\n        log.dim(`  Step ${result.failedStep}: ${result.expected}`);\n      }\n      if (result.actual) {\n        log.dim(`  Got: ${result.actual.slice(0, 200)}`);\n      }\n      if (result.screenshotPath) {\n        log.dim(`  Screenshot: ${result.screenshotPath}`);\n      }\n    }\n  }\n\n  log.dim(`\\nDuration: ${(duration / 1000).toFixed(1)}s`);\n}\n\n/**\n * Format failures into a structured report for the coding agent.\n */\nexport function formatFailureReport(summary: VerificationSummary): string {\n  const lines: string[] = [];\n  lines.push(\n    `## Verification Results: ${summary.passed}/${summary.total} passing\\n`\n  );\n\n  const failures = summary.results.filter((r) => !r.passed);\n  if (failures.length === 0) return lines.join(\"\\n\");\n\n  lines.push(`### ${failures.length} Failing Scenarios\\n`);\n\n  for (const result of failures) {\n    lines.push(`#### ${result.scenario.filePath}`);\n    lines.push(`**Scenario:** ${result.scenario.name}`);\n\n    if (result.failedStep) {\n      const step = result.scenario.steps[result.failedStep - 1];\n      lines.push(`**Failed at step ${result.failedStep}:** ${step}`);\n    }\n\n    if (result.expected) {\n      lines.push(`**Expected:** ${result.expected}`);\n    }\n    if (result.actual) {\n      lines.push(`**Actual:** ${result.actual}`);\n    }\n\n    if (result.consoleLogs.length > 0) {\n      lines.push(`**Console:**`);\n      for (const logEntry of result.consoleLogs.slice(0, 5)) {\n        lines.push(`  ${logEntry}`);\n      }\n    }\n\n    lines.push(\"\");\n  }\n\n  return lines.join(\"\\n\");\n}\n","import { readdirSync, statSync } from \"fs\";\nimport { join, extname } from \"path\";\nimport { parseScenarioFile } from \"./parser.js\";\nimport type { Scenario } from \"./types.js\";\n\n/**\n * Recursively find and parse all scenario .md files in the scenarios directory.\n */\nexport function loadAllScenarios(scenariosDir: string): Scenario[] {\n  const files = findMarkdownFiles(scenariosDir);\n  return files.map((f) => parseScenarioFile(f, scenariosDir));\n}\n\nfunction findMarkdownFiles(dir: string): string[] {\n  const results: string[] = [];\n\n  let entries: string[];\n  try {\n    entries = readdirSync(dir);\n  } catch {\n    return results;\n  }\n\n  for (const entry of entries) {\n    const fullPath = join(dir, entry);\n    const stat = statSync(fullPath);\n\n    if (stat.isDirectory()) {\n      results.push(...findMarkdownFiles(fullPath));\n    } else if (extname(entry) === \".md\") {\n      results.push(fullPath);\n    }\n  }\n\n  return results.sort();\n}\n","import { readFileSync } from \"fs\";\nimport matter from \"gray-matter\";\nimport type { Scenario, ScenarioMetadata } from \"./types.js\";\nimport { basename, dirname, relative } from \"path\";\n\n/**\n * Parse a scenario markdown file into a structured Scenario object.\n *\n * Expected format:\n * ---\n * priority: high\n * type: happy-path\n * confidence: direct\n * ---\n * # Category — Scenario Name\n *\n * ## Context\n * - precondition 1\n * - precondition 2\n *\n * ## Steps\n * 1. Step one\n * 2. Step two\n *\n * ## Expected\n * - Expected outcome 1\n * - Expected outcome 2\n */\nexport function parseScenarioFile(\n  filePath: string,\n  scenariosDir: string\n): Scenario {\n  const raw = readFileSync(filePath, \"utf-8\");\n  return parseScenario(raw, filePath, scenariosDir);\n}\n\nexport function parseScenario(\n  raw: string,\n  filePath: string,\n  scenariosDir: string\n): Scenario {\n  const { data: frontmatter, content } = matter(raw);\n\n  const metadata: ScenarioMetadata = {\n    priority: frontmatter.priority ?? \"medium\",\n    type: frontmatter.type ?? \"happy-path\",\n    confidence: frontmatter.confidence ?? \"direct\",\n  };\n\n  // Parse the heading for name\n  const headingMatch = content.match(/^#\\s+(.+)$/m);\n  const heading = headingMatch?.[1] ?? basename(filePath, \".md\");\n\n  // Extract category from directory structure or heading\n  const relPath = relative(scenariosDir, filePath);\n  const category = dirname(relPath) === \".\" ? \"general\" : dirname(relPath);\n\n  // Parse name from heading (handles \"Category — Name\" format)\n  const nameParts = heading.split(\"—\").map((s) => s.trim());\n  const name = nameParts.length > 1 ? nameParts[1] : nameParts[0];\n\n  // Extract sections\n  const context = extractSection(content, \"Context\");\n  const steps = extractSection(content, \"Steps\");\n  const expected = extractSection(content, \"Expected\");\n\n  return {\n    name,\n    category,\n    filePath,\n    context,\n    steps,\n    expected,\n    metadata,\n    raw,\n  };\n}\n\nfunction extractSection(content: string, sectionName: string): string[] {\n  const sectionRegex = new RegExp(\n    `##\\\\s+${sectionName}\\\\s*\\\\n([\\\\s\\\\S]*?)(?=\\\\n##\\\\s|$)`,\n    \"i\"\n  );\n  const match = content.match(sectionRegex);\n  if (!match) return [];\n\n  const sectionContent = match[1].trim();\n\n  // Parse list items (both - and numbered)\n  return sectionContent\n    .split(\"\\n\")\n    .map((line) => line.replace(/^\\s*[-*]\\s+/, \"\").replace(/^\\s*\\d+\\.\\s+/, \"\").trim())\n    .filter((line) => line.length > 0);\n}\n","import { chat } from \"../utils/claude.js\";\nimport type { Scenario } from \"../scenarios/types.js\";\n\nexport interface PlaywrightAction {\n  type: \"navigate\" | \"click\" | \"fill\" | \"select\" | \"wait\" | \"assert\" | \"keyboard\";\n  selector?: string;\n  value?: string;\n  url?: string;\n  key?: string;\n  description: string;\n}\n\nconst TRANSLATION_SYSTEM = `You are a Playwright test translator. Given a behavioral scenario written in natural language and the current page's content, output a JSON array of Playwright actions.\n\nEach action must be one of these types:\n\n- navigate: Go to a URL. { \"type\": \"navigate\", \"url\": \"/path\", \"description\": \"...\" }\n- click: Click an element. { \"type\": \"click\", \"selector\": \"role/text selector\", \"description\": \"...\" }\n- fill: Type into an input. { \"type\": \"fill\", \"selector\": \"role/text selector\", \"value\": \"text to type\", \"description\": \"...\" }\n- select: Select from a dropdown. { \"type\": \"select\", \"selector\": \"role/text selector\", \"value\": \"option\", \"description\": \"...\" }\n- wait: Wait for something. { \"type\": \"wait\", \"selector\": \"role/text selector or timeout\", \"description\": \"...\" }\n- assert: Verify something is visible/correct. { \"type\": \"assert\", \"selector\": \"role/text selector\", \"value\": \"expected text (optional)\", \"description\": \"...\" }\n- keyboard: Press a key. { \"type\": \"keyboard\", \"key\": \"Enter\", \"description\": \"...\" }\n\nFor selectors, prefer accessible selectors that Playwright supports:\n- getByRole: 'button[name=\"Submit\"]', 'link[name=\"Home\"]', 'textbox[name=\"Email\"]'\n- getByText: 'text=Welcome back'\n- getByPlaceholder: 'placeholder=Enter your email'\n- getByLabel: 'label=Email address'\n- CSS as last resort: '.class-name', '#id'\n\nReturn ONLY a JSON array of actions. No other text.`;\n\n/**\n * Translate a scenario's steps + expected outcomes into Playwright actions.\n */\nexport async function translateScenario(\n  scenario: Scenario,\n  baseUrl: string,\n  model?: string\n): Promise<PlaywrightAction[]> {\n  const prompt = `## Scenario: ${scenario.name}\n\n## Context (preconditions)\n${scenario.context.map((c) => `- ${c}`).join(\"\\n\")}\n\n## Steps to execute\n${scenario.steps.map((s, i) => `${i + 1}. ${s}`).join(\"\\n\")}\n\n## Expected outcomes to verify\n${scenario.expected.map((e) => `- ${e}`).join(\"\\n\")}\n\n## Base URL: ${baseUrl}\n\nTranslate ALL steps AND expected outcomes into Playwright actions. Start by navigating to the appropriate page. End with assert actions for each expected outcome. Return ONLY the JSON array.`;\n\n  const response = await chat(\n    [{ role: \"user\", content: prompt }],\n    {\n      system: TRANSLATION_SYSTEM,\n      model: model ?? \"claude-sonnet-4-5-20250929\",\n      maxTokens: 4096,\n    }\n  );\n\n  // Extract JSON\n  let jsonStr = response.trim();\n  const jsonMatch = jsonStr.match(/```(?:json)?\\s*\\n?([\\s\\S]*?)\\n?```/);\n  if (jsonMatch) {\n    jsonStr = jsonMatch[1].trim();\n  }\n\n  try {\n    const actions = JSON.parse(jsonStr) as PlaywrightAction[];\n    if (!Array.isArray(actions)) throw new Error(\"Not an array\");\n    return actions;\n  } catch {\n    throw new Error(\n      `Failed to translate scenario \"${scenario.name}\" to Playwright actions.\\nResponse: ${response.slice(0, 300)}`\n    );\n  }\n}\n","import { chromium, type Browser, type BrowserContext, type Page } from \"playwright\";\nimport { mkdirSync } from \"fs\";\nimport { join, dirname } from \"path\";\nimport type { PlaywrightAction } from \"./translator.js\";\nimport type { Scenario, StepResult, VerificationResult } from \"../scenarios/types.js\";\n\nexport interface ExecutorOptions {\n  baseUrl: string;\n  headed?: boolean;\n  screenshotDir: string;\n  timeout?: number;\n}\n\nlet browser: Browser | undefined;\n\nexport async function ensureBrowser(headed?: boolean): Promise<Browser> {\n  if (!browser || !browser.isConnected()) {\n    browser = await chromium.launch({\n      headless: !headed,\n    });\n  }\n  return browser;\n}\n\nexport async function closeBrowser(): Promise<void> {\n  if (browser) {\n    await browser.close();\n    browser = undefined;\n  }\n}\n\n/**\n * Execute a single scenario by running its translated Playwright actions.\n */\nexport async function executeScenario(\n  scenario: Scenario,\n  actions: PlaywrightAction[],\n  options: ExecutorOptions\n): Promise<VerificationResult> {\n  const start = Date.now();\n  const stepResults: StepResult[] = [];\n  const consoleLogs: string[] = [];\n  let context: BrowserContext | undefined;\n  let page: Page | undefined;\n\n  try {\n    const b = await ensureBrowser(options.headed);\n    context = await b.newContext({\n      viewport: { width: 1280, height: 720 },\n    });\n    page = await context.newPage();\n\n    // Capture console logs\n    page.on(\"console\", (msg) => {\n      consoleLogs.push(`[${msg.type()}] ${msg.text()}`);\n    });\n\n    page.on(\"pageerror\", (error) => {\n      consoleLogs.push(`[error] ${error.message}`);\n    });\n\n    const timeout = options.timeout ?? 10000;\n\n    for (let i = 0; i < actions.length; i++) {\n      const action = actions[i];\n      const stepResult: StepResult = {\n        step: i + 1,\n        description: action.description,\n        passed: false,\n      };\n\n      try {\n        await executeAction(page, action, options.baseUrl, timeout);\n        stepResult.passed = true;\n      } catch (error) {\n        stepResult.passed = false;\n        stepResult.error =\n          error instanceof Error ? error.message : String(error);\n\n        // Capture screenshot on failure\n        const screenshotName = `${slugify(scenario.name)}-step${i + 1}.png`;\n        const screenshotPath = join(options.screenshotDir, screenshotName);\n        mkdirSync(dirname(screenshotPath), { recursive: true });\n\n        try {\n          await page.screenshot({ path: screenshotPath });\n          stepResult.screenshotPath = screenshotPath;\n        } catch {\n          // Can't take screenshot, continue\n        }\n\n        stepResults.push(stepResult);\n\n        // Stop executing remaining steps on failure\n        return {\n          scenario,\n          passed: false,\n          stepResults,\n          failedStep: i + 1,\n          expected: action.description,\n          actual: stepResult.error,\n          screenshotPath: stepResult.screenshotPath,\n          consoleLogs: consoleLogs.filter(\n            (l) => l.includes(\"[error]\") || l.includes(\"[warning]\")\n          ),\n          duration: Date.now() - start,\n        };\n      }\n\n      stepResults.push(stepResult);\n    }\n\n    return {\n      scenario,\n      passed: true,\n      stepResults,\n      consoleLogs: consoleLogs.filter(\n        (l) => l.includes(\"[error]\") || l.includes(\"[warning]\")\n      ),\n      duration: Date.now() - start,\n    };\n  } finally {\n    if (context) {\n      await context.close().catch(() => {});\n    }\n  }\n}\n\nasync function executeAction(\n  page: Page,\n  action: PlaywrightAction,\n  baseUrl: string,\n  timeout: number\n): Promise<void> {\n  switch (action.type) {\n    case \"navigate\": {\n      const url = action.url?.startsWith(\"http\")\n        ? action.url\n        : `${baseUrl}${action.url}`;\n      await page.goto(url, { waitUntil: \"domcontentloaded\", timeout });\n      break;\n    }\n\n    case \"click\": {\n      const locator = resolveLocator(page, action.selector!);\n      await locator.click({ timeout });\n      break;\n    }\n\n    case \"fill\": {\n      const locator = resolveLocator(page, action.selector!);\n      await locator.fill(action.value!, { timeout });\n      break;\n    }\n\n    case \"select\": {\n      const locator = resolveLocator(page, action.selector!);\n      await locator.selectOption(action.value!, { timeout });\n      break;\n    }\n\n    case \"wait\": {\n      if (action.selector?.match(/^\\d+$/)) {\n        await page.waitForTimeout(parseInt(action.selector));\n      } else if (action.selector) {\n        const locator = resolveLocator(page, action.selector);\n        await locator.waitFor({ state: \"visible\", timeout });\n      } else {\n        await page.waitForTimeout(1000);\n      }\n      break;\n    }\n\n    case \"assert\": {\n      const locator = resolveLocator(page, action.selector!);\n      await locator.waitFor({ state: \"visible\", timeout });\n      if (action.value) {\n        const text = await locator.textContent({ timeout });\n        if (!text?.includes(action.value)) {\n          throw new Error(\n            `Expected text \"${action.value}\" but got \"${text?.slice(0, 100)}\"`\n          );\n        }\n      }\n      break;\n    }\n\n    case \"keyboard\": {\n      await page.keyboard.press(action.key!);\n      break;\n    }\n\n    default:\n      throw new Error(`Unknown action type: ${(action as PlaywrightAction).type}`);\n  }\n}\n\n/**\n * Resolve a selector string into a Playwright Locator.\n * Handles various selector formats including common LLM-generated patterns.\n * Uses .first() to avoid strict mode violations.\n */\nfunction resolveLocator(page: Page, selector: string) {\n  // Handle timeout= patterns (invalid, treat as generic wait)\n  if (selector.startsWith(\"timeout=\") || selector.startsWith(\"timeout:\")) {\n    return page.locator(\"body\");\n  }\n\n  // Handle role= shorthand: 'role=img', 'role=main', 'role=button'\n  const roleShorthand = selector.match(/^role=(\\w+)(?:\\[name=['\"](.+?)['\"]\\])?$/);\n  if (roleShorthand) {\n    const opts = roleShorthand[2] ? { name: roleShorthand[2] } : undefined;\n    return page.getByRole(roleShorthand[1] as Parameters<Page[\"getByRole\"]>[0], opts).first();\n  }\n\n  // Role-based: 'button[name=\"Submit\"]'\n  const roleMatch = selector.match(\n    /^(button|link|textbox|checkbox|radio|heading|img|dialog|alert|navigation|main|form|region|list|listitem|table|row|cell|option|combobox|menu|menuitem)\\[name=['\"](.+?)['\"]\\]$/\n  );\n  if (roleMatch) {\n    return page.getByRole(roleMatch[1] as Parameters<Page[\"getByRole\"]>[0], {\n      name: roleMatch[2],\n    }).first();\n  }\n\n  // Text-based: 'text=...'\n  if (selector.startsWith(\"text=\")) {\n    const textValue = selector.slice(5);\n    return page.getByText(maybeRegex(textValue)).first();\n  }\n\n  // Regex-like text selector: '/pattern/flags'\n  const regexMatch = selector.match(/^\\/(.+?)\\/([gimsuy]*)$/);\n  if (regexMatch) {\n    return page.getByText(new RegExp(regexMatch[1], regexMatch[2])).first();\n  }\n\n  // Playwright getByText shorthand with regex: 'getByText(/pattern/i)'\n  const getByTextRegex = selector.match(/^getByText\\(\\/(.+?)\\/([gimsuy]*)\\)$/);\n  if (getByTextRegex) {\n    return page.getByText(new RegExp(getByTextRegex[1], getByTextRegex[2])).first();\n  }\n\n  // Placeholder-based: 'placeholder=...'\n  if (selector.startsWith(\"placeholder=\")) {\n    return page.getByPlaceholder(selector.slice(12)).first();\n  }\n\n  // Label-based: 'label=...'\n  if (selector.startsWith(\"label=\")) {\n    return page.getByLabel(selector.slice(6)).first();\n  }\n\n  // Test ID: 'testid=...'\n  if (selector.startsWith(\"testid=\")) {\n    return page.getByTestId(selector.slice(7)).first();\n  }\n\n  // CSS fallback — use .first() to avoid strict violations\n  return page.locator(selector).first();\n}\n\n/**\n * Convert a string that looks like a regex (/pattern/flags) to a RegExp,\n * or return the string as-is for plain text matching.\n */\nfunction maybeRegex(text: string): string | RegExp {\n  const match = text.match(/^\\/(.+?)\\/([gimsuy]*)$/);\n  if (match) {\n    return new RegExp(match[1], match[2]);\n  }\n  return text;\n}\n\nfunction slugify(text: string): string {\n  return text\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, \"-\")\n    .replace(/^-|-$/g, \"\");\n}\n","import { spawn, execSync, type ChildProcess } from \"child_process\";\n\nlet serverProcess: ChildProcess | undefined;\n\n/**\n * Check if a server is responding at the given URL.\n */\nexport async function isServerReady(url: string): Promise<boolean> {\n  try {\n    const response = await fetch(url, {\n      signal: AbortSignal.timeout(5000),\n      redirect: \"follow\",\n    });\n    // Accept any response that isn't a server error\n    return response.status < 500;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Wait for a server to become ready, with retries.\n */\nexport async function waitForServer(\n  url: string,\n  maxWaitMs: number = 90000\n): Promise<boolean> {\n  const start = Date.now();\n  while (Date.now() - start < maxWaitMs) {\n    if (await isServerReady(url)) return true;\n    await new Promise((r) => setTimeout(r, 2000));\n  }\n  return false;\n}\n\n/**\n * Start the dev server using the configured command.\n */\nexport function startDevServer(command: string, cwd: string): ChildProcess {\n  // Kill any existing process on the target port first\n  killProcessOnPort(3000);\n\n  const [cmd, ...args] = command.split(\" \");\n  serverProcess = spawn(cmd, args, {\n    cwd,\n    stdio: \"pipe\",\n    env: { ...process.env, PORT: \"3000\" },\n    shell: true,\n  });\n\n  serverProcess.stdout?.on(\"data\", () => {});\n  serverProcess.stderr?.on(\"data\", () => {});\n\n  serverProcess.on(\"exit\", () => {\n    serverProcess = undefined;\n  });\n\n  return serverProcess;\n}\n\n/**\n * Stop the dev server if we started it.\n */\nexport function stopDevServer(): void {\n  if (serverProcess && !serverProcess.killed) {\n    try {\n      serverProcess.kill(\"SIGTERM\");\n    } catch {\n      // ignore\n    }\n    serverProcess = undefined;\n  }\n  // Also kill anything on port 3000 as a safety net\n  killProcessOnPort(3000);\n}\n\n/**\n * Kill any process listening on the given port.\n */\nfunction killProcessOnPort(port: number): void {\n  try {\n    const pids = execSync(`lsof -ti:${port} 2>/dev/null`, {\n      encoding: \"utf-8\",\n    }).trim();\n    if (pids) {\n      for (const pid of pids.split(\"\\n\")) {\n        try {\n          process.kill(parseInt(pid), \"SIGTERM\");\n        } catch {\n          // ignore\n        }\n      }\n      // Give processes time to die\n      execSync(\"sleep 1\");\n    }\n  } catch {\n    // No process on port, that's fine\n  }\n}\n\n/**\n * Ensure a dev server is running. If not, start it with the given command.\n */\nexport async function ensureDevServer(\n  baseUrl: string,\n  devCommand?: string,\n  cwd: string = process.cwd()\n): Promise<boolean> {\n  // First check if something is already running\n  if (await isServerReady(baseUrl)) {\n    return true;\n  }\n\n  if (!devCommand) {\n    throw new Error(\n      `No server running at ${baseUrl} and no devCommand configured. ` +\n        `Either start your dev server manually or add devCommand to litmus.config.ts`\n    );\n  }\n\n  // Kill any existing server that might be hung\n  stopDevServer();\n  await new Promise((r) => setTimeout(r, 2000));\n\n  startDevServer(devCommand, cwd);\n  const ready = await waitForServer(baseUrl);\n\n  if (!ready) {\n    stopDevServer();\n    throw new Error(\n      `Dev server failed to start within 90 seconds. Command: ${devCommand}`\n    );\n  }\n\n  return true;\n}\n","import { loadConfig } from \"../config/loader.js\";\nimport { runAllScenarios, printSummary } from \"../runner/scenario-runner.js\";\nimport { stopDevServer } from \"../utils/dev-server.js\";\nimport { log } from \"../utils/logger.js\";\n\nexport async function verifyCommand(options: {\n  headed?: boolean;\n  filter?: string;\n}): Promise<void> {\n  const cwd = process.cwd();\n\n  const config = await loadConfig(cwd);\n\n  try {\n    const summary = await runAllScenarios(config, {\n      headed: options.headed,\n      filter: options.filter,\n    });\n\n    printSummary(summary);\n\n    if (summary.failed > 0) {\n      process.exit(1);\n    }\n  } catch (error) {\n    log.fail(error instanceof Error ? error.message : String(error));\n    process.exit(1);\n  } finally {\n    stopDevServer();\n  }\n}\n","import { writeFileSync, mkdirSync } from \"fs\";\nimport { join } from \"path\";\nimport { invokeCodingAgent } from \"./coding-agent.js\";\nimport { runAllScenarios, formatFailureReport, printSummary } from \"../runner/scenario-runner.js\";\nimport { CircuitBreaker } from \"./circuit-breaker.js\";\nimport { log, spinner } from \"../utils/logger.js\";\nimport { closeBrowser } from \"../runner/executor.js\";\nimport { stopDevServer } from \"../utils/dev-server.js\";\nimport type { ResolvedConfig } from \"../config/schema.js\";\nimport type { VerificationSummary } from \"../scenarios/types.js\";\n\nexport interface LoopOptions {\n  maxIterations: number;\n  maxCost: number;\n  model?: string;\n}\n\nexport interface LoopResult {\n  success: boolean;\n  iterations: number;\n  finalSummary: VerificationSummary;\n  stoppedReason?: string;\n}\n\n/**\n * Run the ralph loop: code → verify → iterate until all scenarios pass.\n */\nexport async function runRalphLoop(\n  config: ResolvedConfig,\n  options: LoopOptions\n): Promise<LoopResult> {\n  const cwd = process.cwd();\n  const litmusDir = join(cwd, \".litmus\");\n  mkdirSync(litmusDir, { recursive: true });\n\n  const circuitBreaker = new CircuitBreaker(5);\n  let lastFailureReport: string | undefined;\n  let lastSummary: VerificationSummary | undefined;\n\n  log.heading(\n    `Starting ralph loop (max ${options.maxIterations} iterations, budget $${options.maxCost})`\n  );\n  console.log(\"\");\n\n  try {\n    for (let iteration = 1; iteration <= options.maxIterations; iteration++) {\n      log.heading(`── Iteration ${iteration} ──`);\n\n      // Step 1: Invoke coding agent\n      const agentResult = await invokeCodingAgent({\n        model: options.model,\n        cwd,\n        scenariosDir: config.scenariosDir,\n        failureReport: lastFailureReport,\n        iteration,\n      });\n\n      // Save agent output for debugging\n      writeFileSync(\n        join(litmusDir, `agent-output-${iteration}.md`),\n        agentResult.output,\n        \"utf-8\"\n      );\n\n      if (!agentResult.success) {\n        log.warn(`Coding agent returned non-zero exit code (iteration ${iteration})`);\n      }\n\n      // Step 2: Verify all scenarios\n      log.info(\"Verifying scenarios...\");\n\n      try {\n        lastSummary = await runAllScenarios(config, {\n          model: options.model,\n        });\n      } catch (error) {\n        log.fail(\n          `Verification failed: ${error instanceof Error ? error.message : error}`\n        );\n        // If verification itself crashes, still continue the loop\n        continue;\n      }\n\n      // Step 3: Report results\n      const { total, passed, failed } = lastSummary;\n      if (failed === 0) {\n        log.success(`All ${total} scenarios passing!`);\n        printSummary(lastSummary);\n        return {\n          success: true,\n          iterations: iteration,\n          finalSummary: lastSummary,\n        };\n      }\n\n      log.info(`${passed}/${total} passing (${failed} failing)`);\n\n      // Step 4: Check circuit breaker\n      circuitBreaker.record(iteration, lastSummary);\n      const stopReason = circuitBreaker.shouldStop();\n\n      if (stopReason) {\n        log.warn(`Circuit breaker: ${stopReason}`);\n\n        const stuckScenarios = circuitBreaker.getStuckScenarios();\n        if (stuckScenarios.length > 0) {\n          log.heading(\"Persistently failing scenarios:\");\n          for (const s of stuckScenarios) {\n            log.dim(`  ${s}`);\n          }\n        }\n\n        printSummary(lastSummary);\n        return {\n          success: false,\n          iterations: iteration,\n          finalSummary: lastSummary,\n          stoppedReason: stopReason,\n        };\n      }\n\n      // Step 5: Format failures for next iteration\n      lastFailureReport = formatFailureReport(lastSummary);\n\n      // Save failure report\n      writeFileSync(\n        join(litmusDir, `failures-${iteration}.md`),\n        lastFailureReport,\n        \"utf-8\"\n      );\n\n      log.dim(\"Failures fed back to coding agent.\\n\");\n    }\n\n    // Hit max iterations\n    log.warn(`Reached maximum iterations (${options.maxIterations})`);\n    if (lastSummary) {\n      printSummary(lastSummary);\n    }\n\n    return {\n      success: false,\n      iterations: options.maxIterations,\n      finalSummary: lastSummary!,\n      stoppedReason: `Reached maximum iterations (${options.maxIterations})`,\n    };\n  } finally {\n    await closeBrowser();\n    stopDevServer();\n  }\n}\n","import { spawn, spawnSync } from \"child_process\";\nimport { writeFileSync } from \"fs\";\nimport { resolve, join } from \"path\";\nimport { log, spinner } from \"../utils/logger.js\";\n\nexport interface CodingAgentOptions {\n  model?: string;\n  cwd: string;\n  scenariosDir: string;\n  failureReport?: string;\n  iteration: number;\n}\n\n/**\n * Invoke the coding agent to implement or fix the feature.\n * Uses Claude Code in headless mode (-p flag).\n */\nexport async function invokeCodingAgent(\n  options: CodingAgentOptions\n): Promise<{ success: boolean; output: string }> {\n  const { cwd } = options;\n\n  const prompt = buildCodingPrompt(options);\n\n  // Write the prompt to a temp file for debugging\n  const promptPath = join(cwd, \".litmus\", \"last-prompt.md\");\n  writeFileSync(promptPath, prompt, \"utf-8\");\n\n  if (!isClaudeCodeAvailable()) {\n    throw new Error(\n      \"Claude Code CLI not found. Install it with: npm install -g @anthropic-ai/claude-code\\n\" +\n        \"Or ensure the `claude` command is available in your PATH.\"\n    );\n  }\n\n  return invokeClaude(prompt, cwd);\n}\n\nfunction buildCodingPrompt(options: CodingAgentOptions): string {\n  const { scenariosDir, failureReport, iteration, cwd } = options;\n  const scenariosPath = resolve(cwd, scenariosDir);\n\n  const parts: string[] = [];\n\n  parts.push(`# Coding Agent — Iteration ${iteration}`);\n  parts.push(\"\");\n  parts.push(\n    \"You are implementing a feature. Your goal is to make ALL behavioral scenarios pass.\"\n  );\n  parts.push(\"\");\n  parts.push(\"## Rules\");\n  parts.push(\"- Read the scenario files to understand what needs to be built\");\n  parts.push(\n    \"- NEVER modify scenario files in specs/scenarios/ — they are the specification\"\n  );\n  parts.push(\"- Follow existing codebase patterns and conventions\");\n  parts.push(\"- Make the minimum changes necessary\");\n  parts.push(\"- If you need to install a package, do so\");\n  parts.push(\"- Focus on making failing scenarios pass without breaking passing ones\");\n  parts.push(\"\");\n  parts.push(`## Scenarios Directory: ${scenariosPath}`);\n  parts.push(\"\");\n\n  if (iteration === 1) {\n    parts.push(\"## Task\");\n    parts.push(\n      \"This is the first iteration. Read all scenario files and implement the feature from scratch.\"\n    );\n    parts.push(\n      \"Start by understanding the scenarios, then implement the code to make them all pass.\"\n    );\n  } else if (failureReport) {\n    parts.push(\"## Previous Verification Results\");\n    parts.push(\"\");\n    parts.push(failureReport);\n    parts.push(\"\");\n    parts.push(\"## Task\");\n    parts.push(\n      \"Fix the failing scenarios listed above. Read the failure details carefully,\"\n    );\n    parts.push(\n      \"diagnose the root cause, and modify the code to make them pass.\"\n    );\n    parts.push(\"Do NOT break scenarios that were previously passing.\");\n  }\n\n  return parts.join(\"\\n\");\n}\n\nfunction isClaudeCodeAvailable(): boolean {\n  try {\n    const result = spawnSync(\"which\", [\"claude\"], { encoding: \"utf-8\" });\n    return result.status === 0;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Invoke Claude Code CLI asynchronously with proper timeout handling.\n */\nasync function invokeClaude(\n  prompt: string,\n  cwd: string\n): Promise<{ success: boolean; output: string }> {\n  const s = spinner(\"Coding agent working...\");\n\n  return new Promise((resolve) => {\n    const chunks: string[] = [];\n    const errChunks: string[] = [];\n\n    const proc = spawn(\n      \"claude\",\n      [\n        \"-p\",\n        prompt,\n        \"--allowedTools\",\n        \"Read,Write,Edit,Bash(npm install:*),Bash(npx:*),Bash(cat:*),Bash(ls:*),Glob,Grep\",\n        \"--output-format\",\n        \"text\",\n      ],\n      {\n        cwd,\n        env: { ...process.env },\n        stdio: [\"ignore\", \"pipe\", \"pipe\"],\n      }\n    );\n\n    proc.stdout?.on(\"data\", (data: Buffer) => {\n      chunks.push(data.toString());\n    });\n\n    proc.stderr?.on(\"data\", (data: Buffer) => {\n      errChunks.push(data.toString());\n    });\n\n    // 10 minute timeout per iteration\n    const timeout = setTimeout(() => {\n      proc.kill(\"SIGTERM\");\n      s.fail(\"Coding agent timed out (10 min)\");\n      resolve({\n        success: false,\n        output: chunks.join(\"\") + \"\\n[TIMED OUT after 10 minutes]\",\n      });\n    }, 600000);\n\n    proc.on(\"close\", (code) => {\n      clearTimeout(timeout);\n      const output = chunks.join(\"\");\n\n      if (code === 0) {\n        s.succeed(\"Coding agent completed\");\n        resolve({ success: true, output });\n      } else {\n        // Claude Code returns non-zero for various reasons, but may still have done work\n        s.succeed(\"Coding agent completed (exit code \" + code + \")\");\n        resolve({ success: code === 0, output: output || errChunks.join(\"\") });\n      }\n    });\n\n    proc.on(\"error\", (error) => {\n      clearTimeout(timeout);\n      s.fail(\"Coding agent error\");\n      resolve({\n        success: false,\n        output: error.message,\n      });\n    });\n  });\n}\n","import type { VerificationSummary } from \"../scenarios/types.js\";\n\nexport interface IterationRecord {\n  iteration: number;\n  passed: number;\n  failed: number;\n  failingScenarios: string[];\n}\n\n/**\n * Track iteration history and detect stagnation.\n */\nexport class CircuitBreaker {\n  private history: IterationRecord[] = [];\n  private maxStagnantIterations: number;\n\n  constructor(maxStagnantIterations: number = 5) {\n    this.maxStagnantIterations = maxStagnantIterations;\n  }\n\n  record(iteration: number, summary: VerificationSummary): void {\n    this.history.push({\n      iteration,\n      passed: summary.passed,\n      failed: summary.failed,\n      failingScenarios: summary.results\n        .filter((r) => !r.passed)\n        .map((r) => r.scenario.filePath),\n    });\n  }\n\n  /**\n   * Check if the loop should stop due to stagnation.\n   * Returns a reason string if should stop, undefined otherwise.\n   */\n  shouldStop(): string | undefined {\n    if (this.history.length < 3) return undefined;\n\n    // Check for no progress: same number of failures for N iterations\n    const recent = this.history.slice(-this.maxStagnantIterations);\n    if (recent.length >= this.maxStagnantIterations) {\n      const failCounts = recent.map((r) => r.failed);\n      const allSame = failCounts.every((c) => c === failCounts[0]);\n      if (allSame && failCounts[0] > 0) {\n        return `No progress: ${failCounts[0]} scenarios have been failing for ${this.maxStagnantIterations} consecutive iterations.`;\n      }\n    }\n\n    // Check for regression: more failures than previous best\n    const bestSoFar = Math.min(...this.history.map((r) => r.failed));\n    const current = this.history[this.history.length - 1];\n    const previous = this.history[this.history.length - 2];\n    if (\n      current.failed > previous.failed &&\n      current.failed > bestSoFar + 3\n    ) {\n      return `Regression detected: ${current.failed} failures (was ${previous.failed}, best was ${bestSoFar}). The coding agent may be making things worse.`;\n    }\n\n    // Check for oscillation: same scenarios alternately passing/failing\n    if (this.history.length >= 4) {\n      const last4 = this.history.slice(-4);\n      const pattern1 = JSON.stringify(last4[0].failingScenarios);\n      const pattern3 = JSON.stringify(last4[2].failingScenarios);\n      const pattern2 = JSON.stringify(last4[1].failingScenarios);\n      const pattern4 = JSON.stringify(last4[3].failingScenarios);\n\n      if (pattern1 === pattern3 && pattern2 === pattern4 && pattern1 !== pattern2) {\n        return \"Oscillation detected: the coding agent is alternating between two states. It may be fixing one scenario while breaking another.\";\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Get a summary of the stuck scenarios for the human.\n   */\n  getStuckScenarios(): string[] {\n    if (this.history.length < 3) return [];\n\n    const recentFailures = this.history.slice(-3);\n    const scenarioSets = recentFailures.map((r) => new Set(r.failingScenarios));\n\n    // Find scenarios that appear in all recent failure sets\n    const firstSet = scenarioSets[0];\n    return [...firstSet].filter((s) =>\n      scenarioSets.every((set) => set.has(s))\n    );\n  }\n\n  getHistory(): IterationRecord[] {\n    return [...this.history];\n  }\n}\n","import { loadConfig } from \"../config/loader.js\";\nimport { runRalphLoop } from \"../loop/ralph.js\";\nimport { log } from \"../utils/logger.js\";\n\nexport async function loopCommand(options: {\n  maxIterations: string;\n  maxCost: string;\n  model?: string;\n}): Promise<void> {\n  const cwd = process.cwd();\n  const config = await loadConfig(cwd);\n\n  const maxIterations = parseInt(options.maxIterations, 10) || config.loop?.maxIterations || 15;\n  const maxCost = parseFloat(options.maxCost) || config.loop?.maxCost || 5;\n  const model = options.model ?? config.loop?.model ?? config.model;\n\n  try {\n    const result = await runRalphLoop(config, {\n      maxIterations,\n      maxCost,\n      model,\n    });\n\n    if (result.success) {\n      log.heading(\"Done!\");\n      log.success(\n        `All scenarios passing after ${result.iterations} iteration${result.iterations === 1 ? \"\" : \"s\"}`\n      );\n    } else {\n      log.heading(\"Loop stopped\");\n      if (result.stoppedReason) {\n        log.warn(result.stoppedReason);\n      }\n      log.info(\n        \"Review the failing scenarios and either fix them or run `litmus loop` again.\"\n      );\n      process.exit(1);\n    }\n  } catch (error) {\n    log.fail(error instanceof Error ? error.message : String(error));\n    process.exit(1);\n  }\n}\n"],"mappings":";;;AAAA,SAAS,eAAe;;;ACAxB,SAAS,YAAY,WAAW,eAAe,oBAAoB;AACnE,SAAS,SAAS,YAAY;;;ACD9B,OAAO,WAAW;AAClB,OAAO,SAAuB;AAEvB,IAAM,MAAM;AAAA,EACjB,MAAM,CAAC,QAAgB,QAAQ,IAAI,MAAM,KAAK,MAAM,IAAI,MAAM,GAAG;AAAA,EACjE,SAAS,CAAC,QAAgB,QAAQ,IAAI,MAAM,MAAM,MAAM,IAAI,MAAM,GAAG;AAAA,EACrE,MAAM,CAAC,QAAgB,QAAQ,IAAI,MAAM,IAAI,MAAM,IAAI,MAAM,GAAG;AAAA,EAChE,MAAM,CAAC,QAAgB,QAAQ,IAAI,MAAM,OAAO,MAAM,IAAI,MAAM,GAAG;AAAA,EACnE,KAAK,CAAC,QAAgB,QAAQ,IAAI,MAAM,IAAI,GAAG,CAAC;AAAA,EAChD,SAAS,CAAC,QAAgB,QAAQ,IAAI,OAAO,MAAM,KAAK,GAAG,CAAC;AAAA,EAC5D,UAAU,CAAC,MAAc,WACvB,QAAQ;AAAA,IACN,KAAK,SAAS,MAAM,MAAM,QAAG,IAAI,MAAM,IAAI,QAAG,CAAC,IAAI,IAAI;AAAA,EACzD;AACJ;AAEO,SAAS,QAAQ,MAAmB;AACzC,SAAO,IAAI,EAAE,MAAM,OAAO,OAAO,CAAC,EAAE,MAAM;AAC5C;;;ADdA,IAAM,kBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBxB,IAAM,mBAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsBzB,IAAM,kBAAkB;AAAA;AAAA;AAAA;AAKxB,eAAsB,cAA6B;AACjD,QAAM,MAAM,QAAQ,IAAI;AAExB,MAAI,QAAQ,wBAAwB;AAGpC,QAAM,aAAa,QAAQ,KAAK,kBAAkB;AAClD,MAAI,WAAW,UAAU,GAAG;AAC1B,QAAI,KAAK,2CAA2C;AAAA,EACtD,OAAO;AACL,kBAAc,YAAY,eAAe;AACzC,QAAI,QAAQ,0BAA0B;AAAA,EACxC;AAGA,QAAM,eAAe,QAAQ,KAAK,iBAAiB;AACnD,YAAU,cAAc,EAAE,WAAW,KAAK,CAAC;AAC3C,MAAI,QAAQ,0BAA0B;AAGtC,QAAM,cAAc,KAAK,cAAc,qBAAqB;AAC5D,MAAI,CAAC,WAAW,WAAW,GAAG;AAC5B,kBAAc,aAAa,gBAAgB;AAC3C,QAAI,QAAQ,+DAA+D;AAAA,EAC7E;AAGA,QAAM,YAAY,QAAQ,KAAK,SAAS;AACxC,YAAU,WAAW,EAAE,WAAW,KAAK,CAAC;AACxC,YAAU,KAAK,WAAW,UAAU,GAAG,EAAE,WAAW,KAAK,CAAC;AAG1D,QAAM,gBAAgB,QAAQ,KAAK,YAAY;AAC/C,MAAI,WAAW,aAAa,GAAG;AAC7B,UAAM,YAAY,aAAa,eAAe,OAAO;AACrD,QAAI,CAAC,UAAU,SAAS,UAAU,GAAG;AACnC,oBAAc,eAAe,YAAY,eAAe;AACxD,UAAI,QAAQ,8BAA8B;AAAA,IAC5C;AAAA,EACF,OAAO;AACL,kBAAc,eAAe,gBAAgB,KAAK,IAAI,IAAI;AAC1D,QAAI,QAAQ,kCAAkC;AAAA,EAChD;AAEA,MAAI,QAAQ,mBAAmB;AAC/B,MAAI,KAAK,8DAA8D;AACvE,MAAI;AAAA,IACF;AAAA,EACF;AACA,MAAI,KAAK,qEAAqE;AAC9E,MAAI,KAAK,8CAA8C;AACzD;;;AEtGA,SAAS,WAAAA,gBAAe;;;ACAxB,SAAS,gBAAAC,eAAc,cAAAC,aAAY,iBAAAC,gBAAe,kBAAkB;AACpE,SAAS,WAAAC,UAAS,QAAAC,aAAqB;AACvC,SAAS,qBAAqB;;;ACF9B,SAAS,SAAS;AAEX,IAAM,mBAAmB,EAAE,OAAO;AAAA,EACvC,UAAU,EAAE,OAAO,EAAE,SAAS;AAAA,EAC9B,UAAU,EACP,OAAO;AAAA,IACN,OAAO,EAAE,OAAO;AAAA,IAChB,UAAU,EAAE,OAAO;AAAA,EACrB,CAAC,EACA,SAAS;AAAA;AAEd,CAAC;AAEM,IAAM,mBAAmB,EAAE,OAAO;AAAA,EACvC,eAAe,EAAE,OAAO,EAAE,QAAQ,EAAE;AAAA,EACpC,SAAS,EAAE,OAAO,EAAE,QAAQ,CAAC;AAAA,EAC7B,OAAO,EAAE,OAAO,EAAE,QAAQ,4BAA4B;AACxD,CAAC;AAEM,IAAM,eAAe,EAAE,OAAO;AAAA,EACnC,SAAS,EAAE,OAAO,EAAE,IAAI;AAAA,EACxB,YAAY,EAAE,OAAO,EAAE,SAAS;AAAA,EAChC,MAAM,iBAAiB,SAAS;AAAA,EAChC,OAAO,EAAE,OAAO,EAAE,SAAS;AAAA,EAC3B,OAAO,EAAE,OAAO,EAAE,QAAQ,4BAA4B;AAAA,EACtD,MAAM,iBAAiB,SAAS,EAAE,QAAQ,CAAC,CAAC;AAAA,EAC5C,cAAc,EAAE,OAAO,EAAE,QAAQ,iBAAiB;AACpD,CAAC;;;ADtBD,SAAS,cAAc;AACvB,SAAS,kBAAkB;AAE3B,IAAM,mBAAmB;AAAA,EACvB;AAAA,EACA;AAAA,EACA;AACF;AAEA,eAAsB,WAAW,KAAsC;AACrE,MAAI;AAEJ,aAAW,YAAY,kBAAkB;AACvC,UAAM,YAAYC,SAAQ,KAAK,QAAQ;AACvC,QAAIC,YAAW,SAAS,GAAG;AACzB,mBAAa;AACb;AAAA,IACF;AAAA,EACF;AAEA,MAAI,CAAC,YAAY;AACf,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,MAAI;AAEJ,MAAI,WAAW,SAAS,KAAK,GAAG;AAC9B,gBAAY,MAAM,aAAa,UAAU;AAAA,EAC3C,OAAO;AACL,UAAM,MAAM,MAAM,OAAO,cAAc,UAAU,EAAE;AACnD,gBAAY,IAAI,WAAW;AAAA,EAC7B;AAGA,QAAM,YACJ,OAAO,WAAW,SAAS,YAC3B,UAAU,SAAS,QACnB,WAAW,UAAU,QACrB,OAAQ,UAAU,KAAiC,UAAU,aACvD,UAAU,KAAiC,QAC7C;AAGN,MAAI,aAAa,OAAO,UAAU,SAAS,YAAY,UAAU,SAAS,MAAM;AAC9E,UAAM,WAAW,EAAE,GAAG,UAAU,KAAK;AACrC,WAAO,SAAS;AAChB,gBAAY,EAAE,GAAG,WAAW,MAAM,SAAS;AAAA,EAC7C;AAEA,QAAM,SAAS,aAAa,MAAM,SAAS;AAE3C,SAAO;AAAA,IACL,GAAG;AAAA,IACH;AAAA,EACF;AACF;AAMA,eAAe,aACb,YACkC;AAClC,QAAM,UAAUC,cAAa,YAAY,OAAO;AAGhD,QAAM,YAAY,QAEf;AAAA,IACC;AAAA,IACA;AAAA,EACF,EAEC,QAAQ,kCAAkC,EAAE,EAE5C,QAAQ,uBAAuB,iBAAiB;AAGnD,QAAM,UAAUC,MAAK,OAAO,GAAG,iBAAiB,WAAW,CAAC,MAAM;AAClE,EAAAC,eAAc,SAAS,WAAW,OAAO;AAEzC,MAAI;AACF,UAAM,MAAM,MAAM,OAAO,cAAc,OAAO,EAAE;AAChD,WAAO,IAAI,WAAW;AAAA,EACxB,UAAE;AACA,QAAI;AACF,iBAAW,OAAO;AAAA,IACpB,QAAQ;AAAA,IAER;AAAA,EACF;AACF;;;AEnGA,SAAS,uBAAuB;;;ACAhC,OAAO,eAAe;AAEtB,IAAI;AAEG,SAAS,YAAuB;AACrC,MAAI,CAAC,QAAQ;AACX,UAAM,SAAS,QAAQ,IAAI;AAC3B,QAAI,CAAC,QAAQ;AACX,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,aAAS,IAAI,UAAU,EAAE,OAAO,CAAC;AAAA,EACnC;AACA,SAAO;AACT;AAOA,eAAsB,KACpB,UACA,UAII,CAAC,GACY;AACjB,QAAM,YAAY,UAAU;AAC5B,QAAM,WAAW,MAAM,UAAU,SAAS,OAAO;AAAA,IAC/C,OAAO,QAAQ,SAAS;AAAA,IACxB,YAAY,QAAQ,aAAa;AAAA,IACjC,QAAQ,QAAQ;AAAA,IAChB;AAAA,EACF,CAAC;AAED,QAAM,YAAY,SAAS,QAAQ,KAAK,CAAC,UAAU,MAAM,SAAS,MAAM;AACxE,SAAO,WAAW,QAAQ;AAC5B;AAEA,gBAAuB,WACrB,UACA,UAII,CAAC,GACmB;AACxB,QAAM,YAAY,UAAU;AAE5B,QAAM,SAAS,UAAU,SAAS,OAAO;AAAA,IACvC,OAAO,QAAQ,SAAS;AAAA,IACxB,YAAY,QAAQ,aAAa;AAAA,IACjC,QAAQ,QAAQ;AAAA,IAChB;AAAA,EACF,CAAC;AAED,mBAAiB,SAAS,QAAQ;AAChC,QACE,MAAM,SAAS,yBACf,MAAM,MAAM,SAAS,cACrB;AACA,YAAM,MAAM,MAAM;AAAA,IACpB;AAAA,EACF;AACF;;;ACnEA,SAAS,cAAAC,aAAY,gBAAAC,eAAc,aAAa,gBAAgB;AAChE,SAAS,QAAAC,aAAqB;AAcvB,SAAS,oBAAoB,KAA8B;AAChE,QAAM,UAA2B;AAAA,IAC/B,OAAO,CAAC;AAAA,IACR,QAAQ,CAAC;AAAA,IACT,QAAQ,CAAC;AAAA,IACT,YAAY,CAAC;AAAA,IACb,eAAe,CAAC;AAAA,IAChB,aAAa;AAAA,EACf;AAGA,QAAM,UAAUA,MAAK,KAAK,cAAc;AACxC,MAAIF,YAAW,OAAO,GAAG;AACvB,QAAI;AACF,cAAQ,cAAc,KAAK,MAAMC,cAAa,SAAS,OAAO,CAAC;AAC/D,cAAQ,MAAM,KAAK,GAAG,YAAY,QAAQ,WAAsC,CAAC;AAAA,IACnF,QAAQ;AAAA,IAER;AAAA,EACF;AAGA,QAAM,SAASC,MAAK,KAAK,KAAK;AAC9B,QAAM,YAAYA,MAAK,KAAK,OAAO,KAAK;AACxC,QAAM,WAAWA,MAAK,KAAK,OAAO;AAClC,QAAM,cAAcA,MAAK,KAAK,OAAO,OAAO;AAE5C,aAAW,OAAO,CAAC,QAAQ,SAAS,GAAG;AACrC,QAAIF,YAAW,GAAG,GAAG;AACnB,cAAQ,OAAO,KAAK,GAAG,kBAAkB,KAAK,GAAG,CAAC;AAAA,IACpD;AAAA,EACF;AAEA,aAAW,OAAO,CAAC,UAAU,WAAW,GAAG;AACzC,QAAIA,YAAW,GAAG,GAAG;AACnB,cAAQ,OAAO,KAAK,GAAG,mBAAmB,KAAK,GAAG,CAAC;AAAA,IACrD;AAAA,EACF;AAGA,QAAM,aAAaE,MAAK,KAAK,UAAU,eAAe;AACtD,MAAIF,YAAW,UAAU,GAAG;AAC1B,UAAM,SAASC,cAAa,YAAY,OAAO;AAC/C,YAAQ,OAAO,KAAK,SAAS,QAAQ,GAAI,CAAC;AAC1C,YAAQ,MAAM,KAAK,YAAY;AAAA,EACjC;AAGA,QAAM,eAAe;AAAA,IAAU;AAAA,IAAK,CAAC,MACnC,EAAE,SAAS,QAAQ,MAAM,EAAE,SAAS,KAAK,KAAK,EAAE,SAAS,KAAK,MAAM,EAAE,SAAS,SAAS;AAAA,EAC1F;AACA,aAAW,KAAK,aAAa,MAAM,GAAG,CAAC,GAAG;AACxC,YAAQ,OAAO,KAAK,SAASA,cAAa,GAAG,OAAO,GAAG,GAAI,CAAC;AAC5D,QAAI,CAAC,QAAQ,MAAM,SAAS,aAAa,EAAG,SAAQ,MAAM,KAAK,aAAa;AAAA,EAC9E;AAGA,QAAM,gBAAgB,CAAC,cAAc,kBAAkB,gBAAgB;AACvE,aAAW,OAAO,eAAe;AAC/B,UAAM,UAAUC,MAAK,KAAK,GAAG;AAC7B,QAAIF,YAAW,OAAO,GAAG;AACvB,cAAQ,WAAW;AAAA,QACjB,GAAG,iBAAiB,OAAO,EAAE,IAAI,CAAC,MAAM,EAAE,QAAQ,MAAM,KAAK,EAAE,CAAC;AAAA,MAClE;AAAA,IACF;AAAA,EACF;AAGA,QAAM,eAAe,CAAC,aAAa,SAAS,QAAQ,QAAQ,YAAY,UAAU;AAClF,QAAM,YAAY,UAAU,KAAK,CAAC,MAAM;AACtC,UAAM,QAAQ,EAAE,YAAY;AAC5B,YACG,MAAM,SAAS,QAAQ,KAAK,MAAM,SAAS,QAAQ,KAAK,MAAM,SAAS,WAAW,MACnF,CAAC,MAAM,SAAS,cAAc;AAAA,EAElC,CAAC;AACD,UAAQ,gBAAgB,UAAU,MAAM,GAAG,EAAE,EAAE,IAAI,CAAC,MAAM,EAAE,QAAQ,MAAM,KAAK,EAAE,CAAC;AAElF,SAAO;AACT;AAEA,SAAS,YAAY,KAAwC;AAC3D,QAAM,QAAkB,CAAC;AACzB,QAAM,OAAO;AAAA,IACX,GAAI,IAAI,gBAA0C,CAAC;AAAA,IACnD,GAAI,IAAI,mBAA6C,CAAC;AAAA,EACxD;AAEA,MAAI,KAAK,MAAM,EAAG,OAAM,KAAK,WAAW,KAAK,MAAM,CAAC,EAAE;AACtD,MAAI,KAAK,OAAO,EAAG,OAAM,KAAK,OAAO;AACrC,MAAI,KAAK,KAAK,EAAG,OAAM,KAAK,KAAK;AACjC,MAAI,KAAK,QAAQ,KAAK,KAAK,eAAe,EAAG,OAAM,KAAK,kBAAkB;AAC1E,MAAI,KAAK,SAAS,EAAG,OAAM,KAAK,SAAS;AACzC,MAAI,KAAK,uBAAuB,EAAG,OAAM,KAAK,UAAU;AACxD,MAAI,KAAK,UAAU,EAAG,OAAM,KAAK,UAAU;AAC3C,MAAI,KAAK,QAAQ,EAAG,OAAM,KAAK,QAAQ;AACvC,MAAI,KAAK,YAAY,KAAK,KAAK,WAAW,EAAG,OAAM,KAAK,kBAAkB;AAC1E,MAAI,KAAK,eAAe,EAAG,OAAM,KAAK,YAAY;AAClD,MAAI,KAAK,aAAa,EAAG,OAAM,KAAK,cAAc;AAClD,MAAI,KAAK,QAAQ,KAAK,KAAK,gBAAgB,EAAG,OAAM,KAAK,QAAQ;AACjE,MAAI,KAAK,aAAa,EAAG,OAAM,KAAK,aAAa;AAEjD,SAAO;AACT;AAEA,SAAS,kBAAkB,KAAa,SAA2B;AACjE,QAAM,SAAmB,CAAC;AAC1B,MAAI;AACF,eAAW,SAAS,YAAY,GAAG,GAAG;AACpC,YAAM,WAAWE,MAAK,KAAK,KAAK;AAChC,UAAI,SAAS,QAAQ,EAAE,YAAY,GAAG;AACpC,YAAI,CAAC,MAAM,WAAW,GAAG,KAAK,CAAC,MAAM,WAAW,GAAG,GAAG;AACpD,iBAAO,KAAK,GAAG,kBAAkB,UAAU,OAAO,CAAC;AAAA,QACrD;AAAA,MACF,WAAW,MAAM,WAAW,OAAO,GAAG;AACpC,cAAM,QAAQ,IAAI,QAAQ,SAAS,EAAE,EAAE,QAAQ,OAAO,GAAG,KAAK;AAC9D,eAAO,KAAK,KAAK;AAAA,MACnB;AAAA,IACF;AAAA,EACF,QAAQ;AAAA,EAER;AACA,SAAO;AACT;AAEA,SAAS,mBAAmB,KAAa,SAA2B;AAClE,QAAM,SAAmB,CAAC;AAC1B,MAAI;AACF,eAAW,SAAS,YAAY,GAAG,GAAG;AACpC,YAAM,WAAWA,MAAK,KAAK,KAAK;AAChC,UAAI,SAAS,QAAQ,EAAE,YAAY,GAAG;AACpC,eAAO,KAAK,GAAG,mBAAmB,UAAU,OAAO,CAAC;AAAA,MACtD,WAAW,iBAAiB,KAAK,KAAK,KAAK,CAAC,MAAM,WAAW,GAAG,GAAG;AACjE,cAAM,QAAQ,SACX,QAAQ,SAAS,EAAE,EACnB,QAAQ,OAAO,GAAG,EAClB,QAAQ,kBAAkB,EAAE,EAC5B,QAAQ,YAAY,GAAG;AAC1B,eAAO,KAAK,KAAK;AAAA,MACnB;AAAA,IACF;AAAA,EACF,QAAQ;AAAA,EAER;AACA,SAAO;AACT;AAEA,SAAS,UACP,KACA,WACA,WAAmB,GACnB,eAAuB,GACb;AACV,MAAI,gBAAgB,SAAU,QAAO,CAAC;AACtC,QAAM,UAAoB,CAAC;AAE3B,MAAI;AACF,eAAW,SAAS,YAAY,GAAG,GAAG;AACpC,UAAI,UAAU,kBAAkB,UAAU,UAAU,UAAU,WAAW,UAAU,QAAQ;AACzF;AAAA,MACF;AACA,YAAM,WAAWA,MAAK,KAAK,KAAK;AAChC,YAAM,OAAO,SAAS,QAAQ;AAC9B,UAAI,KAAK,YAAY,GAAG;AACtB,gBAAQ,KAAK,GAAG,UAAU,UAAU,WAAW,UAAU,eAAe,CAAC,CAAC;AAAA,MAC5E,WAAW,UAAU,QAAQ,GAAG;AAC9B,gBAAQ,KAAK,QAAQ;AAAA,MACvB;AAAA,IACF;AAAA,EACF,QAAQ;AAAA,EAER;AAEA,SAAO;AACT;AAEA,SAAS,iBAAiB,KAAuB;AAC/C,MAAI;AACF,WAAO,YAAY,GAAG,EACnB,IAAI,CAAC,MAAMA,MAAK,KAAK,CAAC,CAAC,EACvB,OAAO,CAAC,MAAM,SAAS,CAAC,EAAE,OAAO,CAAC,EAClC,MAAM,GAAG,EAAE;AAAA,EAChB,QAAQ;AACN,WAAO,CAAC;AAAA,EACV;AACF;AAEA,SAAS,SAAS,MAAc,WAA2B;AACzD,MAAI,KAAK,UAAU,UAAW,QAAO;AACrC,SAAO,KAAK,MAAM,GAAG,SAAS,IAAI;AACpC;AAKO,SAAS,sBAAsB,KAA8B;AAClE,QAAM,QAAkB,CAAC;AAEzB,MAAI,IAAI,MAAM,SAAS,GAAG;AACxB,UAAM,KAAK,mBAAmB,IAAI,MAAM,KAAK,IAAI,CAAC,EAAE;AAAA,EACtD;AAEA,MAAI,IAAI,OAAO,SAAS,GAAG;AACzB,UAAM,KAAK,eAAe,IAAI,OAAO,KAAK,IAAI,CAAC,EAAE;AAAA,EACnD;AAEA,MAAI,IAAI,WAAW,SAAS,GAAG;AAC7B,UAAM,KAAK,mBAAmB,IAAI,WAAW,MAAM,GAAG,EAAE,EAAE,KAAK,IAAI,CAAC,EAAE;AAAA,EACxE;AAEA,MAAI,IAAI,OAAO,SAAS,GAAG;AACzB,UAAM,KAAK;AAAA;AAAA,EAAiC,IAAI,OAAO,KAAK,MAAM,CAAC;AAAA,OAAU;AAAA,EAC/E;AAEA,MAAI,IAAI,cAAc,SAAS,GAAG;AAChC,UAAM,KAAK,uBAAuB,IAAI,cAAc,KAAK,IAAI,CAAC,EAAE;AAAA,EAClE;AAEA,SAAO,MAAM,KAAK,MAAM;AAC1B;;;AC1OO,IAAM,mBAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmDzB,IAAM,mBAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AH1ChC,SAAS,IAAI,IAAwC,QAAiC;AACpF,SAAO,IAAI,QAAQ,CAACC,aAAY;AAC9B,OAAG,SAAS,QAAQ,CAAC,WAAWA,SAAQ,MAAM,CAAC;AAAA,EACjD,CAAC;AACH;AAWA,eAAsB,aACpB,oBACA,SAC0B;AAC1B,QAAM,IAAI,QAAQ,qBAAqB;AACvC,QAAM,kBAAkB,oBAAoB,QAAQ,GAAG;AACvD,IAAE,QAAQ,mBAAmB;AAE7B,QAAM,aAAa,sBAAsB,eAAe;AACxD,MAAI,YAAY;AACd,QAAI;AAAA,MACF,UAAU,gBAAgB,MAAM,KAAK,IAAI,KAAK,eAAe,KAAK,gBAAgB,OAAO,MAAM;AAAA,IACjG;AAAA,EACF;AAEA,QAAM,eAAe,GAAG,gBAAgB;AAAA;AAAA;AAAA;AAAA,EAA8B,UAAU;AAEhF,QAAM,WAAsB;AAAA,IAC1B;AAAA,MACE,MAAM;AAAA,MACN,SAAS,0CAA0C,kBAAkB;AAAA;AAAA;AAAA,IACvE;AAAA,EACF;AAEA,QAAM,KAAK,gBAAgB;AAAA,IACzB,OAAO,QAAQ;AAAA,IACf,QAAQ,QAAQ;AAAA,EAClB,CAAC;AAED,QAAM,QAAQ,QAAQ,SAAS;AAE/B,MAAI;AACF,WAAO,MAAM;AAEX,cAAQ,OAAO,MAAM,IAAI;AACzB,UAAI,eAAe;AAEnB,uBAAiB,SAAS,WAAW,UAAU;AAAA,QAC7C,QAAQ;AAAA,QACR;AAAA,MACF,CAAC,GAAG;AACF,gBAAQ,OAAO,MAAM,KAAK;AAC1B,wBAAgB;AAAA,MAClB;AAEA,cAAQ,OAAO,MAAM,IAAI;AAEzB,eAAS,KAAK,EAAE,MAAM,aAAa,SAAS,aAAa,CAAC;AAG1D,UAAI,aAAa,SAAS,iBAAiB,GAAG;AAC5C,cAAM,oBAAoB,aAAa;AAAA,UACrC;AAAA,QACF;AACA,YAAI,mBAAmB;AACrB,cAAI,QAAQ,gDAAgD;AAC5D,aAAG,MAAM;AACT,iBAAO;AAAA,YACL,cAAc,kBAAkB,CAAC;AAAA,YACjC,qBAAqB;AAAA,UACvB;AAAA,QACF;AAAA,MACF;AAGA,YAAM,YAAY,MAAM,IAAI,IAAI,MAAM;AAEtC,UACE,UAAU,YAAY,MAAM,UAC5B,UAAU,YAAY,MAAM,YAC5B;AACA,iBAAS,KAAK;AAAA,UACZ,MAAM;AAAA,UACN,SACE;AAAA,QACJ,CAAC;AAAA,MACH,OAAO;AACL,iBAAS,KAAK,EAAE,MAAM,QAAQ,SAAS,UAAU,CAAC;AAAA,MACpD;AAAA,IACF;AAAA,EACF,UAAE;AACA,OAAG,MAAM;AAAA,EACX;AACF;;;AI3GA,SAAS,aAAAC,YAAW,iBAAAC,sBAAqB;AACzC,SAAS,WAAAC,UAAS,QAAAC,aAAY;AAYvB,SAAS,kBACd,UACA,cACQ;AACR,QAAM,UAAU,eAAe,QAAQ;AACvC,QAAM,WAAW,QAAQ,SAAS,IAAI,IAAI;AAC1C,QAAM,WAAWA,MAAK,cAAc,SAAS,UAAU,QAAQ;AAE/D,EAAAH,WAAUE,SAAQ,QAAQ,GAAG,EAAE,WAAW,KAAK,CAAC;AAChD,EAAAD,eAAc,UAAU,SAAS,OAAO;AAExC,SAAO;AACT;AAEO,SAAS,eAAe,UAAiC;AAC9D,QAAM,QAAkB,CAAC;AAGzB,QAAM,KAAK,KAAK;AAChB,QAAM,KAAK,aAAa,SAAS,SAAS,QAAQ,EAAE;AACpD,QAAM,KAAK,SAAS,SAAS,SAAS,IAAI,EAAE;AAC5C,QAAM,KAAK,eAAe,SAAS,SAAS,UAAU,EAAE;AACxD,QAAM,KAAK,KAAK;AAChB,QAAM,KAAK,EAAE;AAGb,QAAM,KAAK,KAAK,WAAW,SAAS,QAAQ,CAAC,WAAM,SAAS,IAAI,EAAE;AAClE,QAAM,KAAK,EAAE;AAGb,QAAM,KAAK,YAAY;AACvB,aAAW,QAAQ,SAAS,SAAS;AACnC,UAAM,KAAK,KAAK,IAAI,EAAE;AAAA,EACxB;AACA,QAAM,KAAK,EAAE;AAGb,QAAM,KAAK,UAAU;AACrB,WAAS,MAAM,QAAQ,CAAC,MAAM,MAAM;AAClC,UAAM,KAAK,GAAG,IAAI,CAAC,KAAK,IAAI,EAAE;AAAA,EAChC,CAAC;AACD,QAAM,KAAK,EAAE;AAGb,QAAM,KAAK,aAAa;AACxB,aAAW,QAAQ,SAAS,UAAU;AACpC,UAAM,KAAK,KAAK,IAAI,EAAE;AAAA,EACxB;AACA,QAAM,KAAK,EAAE;AAEb,SAAO,MAAM,KAAK,IAAI;AACxB;AAEA,SAAS,QAAQ,MAAsB;AACrC,SAAO,KACJ,YAAY,EACZ,QAAQ,eAAe,GAAG,EAC1B,QAAQ,UAAU,EAAE;AACzB;AAEA,SAAS,WAAW,MAAsB;AACxC,SAAO,KAAK,OAAO,CAAC,EAAE,YAAY,IAAI,KAAK,MAAM,CAAC;AACpD;;;ACxDA,eAAsB,gBACpB,cACA,iBACA,SAIsG;AACtG,QAAM,IAAI,QAAQ,yBAAyB;AAE3C,QAAM,WAAW,MAAM;AAAA,IACrB;AAAA,MACE;AAAA,QACE,MAAM;AAAA,QACN,SAAS;AAAA;AAAA,EAAsB,YAAY;AAAA;AAAA;AAAA;AAAA,EAA8B,eAAe;AAAA;AAAA;AAAA,MAC1F;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,OAAO,QAAQ,SAAS;AAAA,MACxB,WAAW;AAAA,IACb;AAAA,EACF;AAEA,IAAE,OAAO;AAGT,MAAI,UAAU,SAAS,KAAK;AAC5B,QAAM,YAAY,QAAQ,MAAM,oCAAoC;AACpE,MAAI,WAAW;AACb,cAAU,UAAU,CAAC,EAAE,KAAK;AAAA,EAC9B;AAEA,MAAI;AACJ,MAAI;AACF,gBAAY,KAAK,MAAM,OAAO;AAAA,EAChC,QAAQ;AACN,MAAE,KAAK,qCAAqC;AAC5C,UAAM,IAAI;AAAA,MACR;AAAA,EAAsE,SAAS,MAAM,GAAG,GAAG,CAAC;AAAA,IAC9F;AAAA,EACF;AAEA,MAAI,CAAC,MAAM,QAAQ,SAAS,KAAK,UAAU,WAAW,GAAG;AACvD,MAAE,KAAK,wBAAwB;AAC/B,UAAM,IAAI,MAAM,oDAAoD;AAAA,EACtE;AAEA,IAAE,OAAO,WAAW,UAAU,MAAM;AAEpC,QAAM,aAAqC,CAAC;AAC5C,QAAM,eAAuC,CAAC;AAE9C,aAAW,YAAY,WAAW;AAChC,UAAM,QAAuB;AAAA,MAC3B,MAAM,SAAS;AAAA,MACf,UAAU,SAAS;AAAA,MACnB,SAAS,SAAS,WAAW,CAAC;AAAA,MAC9B,OAAO,SAAS,SAAS,CAAC;AAAA,MAC1B,UAAU,SAAS,YAAY,CAAC;AAAA,MAChC,UAAU;AAAA,QACR,UAAU,SAAS,UAAU,YAAY;AAAA,QACzC,MAAM,SAAS,UAAU,QAAQ;AAAA,QACjC,YAAY,SAAS,UAAU,cAAc;AAAA,MAC/C;AAAA,IACF;AAEA,sBAAkB,OAAO,QAAQ,YAAY;AAE7C,eAAW,MAAM,QAAQ,KAAK,WAAW,MAAM,QAAQ,KAAK,KAAK;AACjE,iBAAa,MAAM,SAAS,UAAU,KACnC,aAAa,MAAM,SAAS,UAAU,KAAK,KAAK;AAAA,EACrD;AAEA,IAAE,QAAQ,aAAa,UAAU,MAAM,YAAY;AAEnD,SAAO;AAAA,IACL,OAAO,UAAU;AAAA,IACjB;AAAA,IACA;AAAA,EACF;AACF;;;AR1FA,eAAsB,YACpB,aACA,SACe;AACf,QAAM,MAAM,QAAQ,IAAI;AAExB,MAAI;AACJ,MAAI;AACF,aAAS,MAAM,WAAW,GAAG;AAAA,EAC/B,QAAQ;AACN,QAAI,KAAK,yCAAyC;AAClD,aAAS;AAAA,MACP,SAAS;AAAA,MACT,cAAc;AAAA,MACd,OAAO;AAAA,MACP,MAAM,EAAE,eAAe,IAAI,SAAS,GAAG,OAAO,6BAA6B;AAAA,IAC7E;AAAA,EACF;AAEA,QAAM,QAAQ,QAAQ,SAAS,OAAO;AAGtC,QAAM,EAAE,aAAa,IAAI,MAAM,aAAa,aAAa;AAAA,IACvD;AAAA,IACA;AAAA,EACF,CAAC;AAGD,QAAM,cAAc,oBAAoB,GAAG;AAC3C,QAAM,aAAa,sBAAsB,WAAW;AAGpD,QAAM,eAAeG,SAAQ,KAAK,OAAO,YAAY;AACrD,QAAM,SAAS,MAAM,gBAAgB,cAAc,YAAY;AAAA,IAC7D;AAAA,IACA;AAAA,EACF,CAAC;AAGD,MAAI,QAAQ,kBAAkB;AAC9B,MAAI,KAAK,UAAU,OAAO,KAAK,YAAY;AAE3C,MAAI,QAAQ,cAAc;AAC1B,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,OAAO,UAAU,GAAG;AAC5D,QAAI,KAAK,KAAK,GAAG,KAAK,KAAK,EAAE;AAAA,EAC/B;AAEA,MAAI,QAAQ,gBAAgB;AAC5B,aAAW,CAAC,MAAM,KAAK,KAAK,OAAO,QAAQ,OAAO,YAAY,GAAG;AAC/D,QAAI,KAAK,KAAK,IAAI,KAAK,KAAK,EAAE;AAAA,EAChC;AAEA,UAAQ,IAAI,EAAE;AACd,MAAI;AAAA,IACF,wBAAwB,OAAO,YAAY;AAAA,EAC7C;AACA,MAAI,KAAK,oDAAoD;AAC/D;;;ASnEA,SAAS,WAAAC,gBAAe;;;ACAxB,SAAS,eAAAC,cAAa,YAAAC,iBAAgB;AACtC,SAAS,QAAAC,OAAM,WAAAC,gBAAe;;;ACD9B,SAAS,gBAAAC,qBAAoB;AAC7B,OAAO,YAAY;AAEnB,SAAS,UAAU,WAAAC,UAAS,gBAAgB;AAyBrC,SAAS,kBACd,UACA,cACU;AACV,QAAM,MAAMD,cAAa,UAAU,OAAO;AAC1C,SAAO,cAAc,KAAK,UAAU,YAAY;AAClD;AAEO,SAAS,cACd,KACA,UACA,cACU;AACV,QAAM,EAAE,MAAM,aAAa,QAAQ,IAAI,OAAO,GAAG;AAEjD,QAAM,WAA6B;AAAA,IACjC,UAAU,YAAY,YAAY;AAAA,IAClC,MAAM,YAAY,QAAQ;AAAA,IAC1B,YAAY,YAAY,cAAc;AAAA,EACxC;AAGA,QAAM,eAAe,QAAQ,MAAM,aAAa;AAChD,QAAM,UAAU,eAAe,CAAC,KAAK,SAAS,UAAU,KAAK;AAG7D,QAAM,UAAU,SAAS,cAAc,QAAQ;AAC/C,QAAM,WAAWC,SAAQ,OAAO,MAAM,MAAM,YAAYA,SAAQ,OAAO;AAGvE,QAAM,YAAY,QAAQ,MAAM,QAAG,EAAE,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC;AACxD,QAAM,OAAO,UAAU,SAAS,IAAI,UAAU,CAAC,IAAI,UAAU,CAAC;AAG9D,QAAM,UAAU,eAAe,SAAS,SAAS;AACjD,QAAM,QAAQ,eAAe,SAAS,OAAO;AAC7C,QAAM,WAAW,eAAe,SAAS,UAAU;AAEnD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEA,SAAS,eAAe,SAAiB,aAA+B;AACtE,QAAM,eAAe,IAAI;AAAA,IACvB,SAAS,WAAW;AAAA,IACpB;AAAA,EACF;AACA,QAAM,QAAQ,QAAQ,MAAM,YAAY;AACxC,MAAI,CAAC,MAAO,QAAO,CAAC;AAEpB,QAAM,iBAAiB,MAAM,CAAC,EAAE,KAAK;AAGrC,SAAO,eACJ,MAAM,IAAI,EACV,IAAI,CAAC,SAAS,KAAK,QAAQ,eAAe,EAAE,EAAE,QAAQ,gBAAgB,EAAE,EAAE,KAAK,CAAC,EAChF,OAAO,CAAC,SAAS,KAAK,SAAS,CAAC;AACrC;;;ADrFO,SAAS,iBAAiB,cAAkC;AACjE,QAAM,QAAQ,kBAAkB,YAAY;AAC5C,SAAO,MAAM,IAAI,CAAC,MAAM,kBAAkB,GAAG,YAAY,CAAC;AAC5D;AAEA,SAAS,kBAAkB,KAAuB;AAChD,QAAM,UAAoB,CAAC;AAE3B,MAAI;AACJ,MAAI;AACF,cAAUC,aAAY,GAAG;AAAA,EAC3B,QAAQ;AACN,WAAO;AAAA,EACT;AAEA,aAAW,SAAS,SAAS;AAC3B,UAAM,WAAWC,MAAK,KAAK,KAAK;AAChC,UAAM,OAAOC,UAAS,QAAQ;AAE9B,QAAI,KAAK,YAAY,GAAG;AACtB,cAAQ,KAAK,GAAG,kBAAkB,QAAQ,CAAC;AAAA,IAC7C,WAAWC,SAAQ,KAAK,MAAM,OAAO;AACnC,cAAQ,KAAK,QAAQ;AAAA,IACvB;AAAA,EACF;AAEA,SAAO,QAAQ,KAAK;AACtB;;;AEvBA,IAAM,qBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwB3B,eAAsB,kBACpB,UACA,SACA,OAC6B;AAC7B,QAAM,SAAS,gBAAgB,SAAS,IAAI;AAAA;AAAA;AAAA,EAG5C,SAAS,QAAQ,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC;AAAA;AAAA;AAAA,EAGhD,SAAS,MAAM,IAAI,CAAC,GAAG,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC;AAAA;AAAA;AAAA,EAGzD,SAAS,SAAS,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC;AAAA;AAAA,eAEpC,OAAO;AAAA;AAAA;AAIpB,QAAM,WAAW,MAAM;AAAA,IACrB,CAAC,EAAE,MAAM,QAAQ,SAAS,OAAO,CAAC;AAAA,IAClC;AAAA,MACE,QAAQ;AAAA,MACR,OAAO,SAAS;AAAA,MAChB,WAAW;AAAA,IACb;AAAA,EACF;AAGA,MAAI,UAAU,SAAS,KAAK;AAC5B,QAAM,YAAY,QAAQ,MAAM,oCAAoC;AACpE,MAAI,WAAW;AACb,cAAU,UAAU,CAAC,EAAE,KAAK;AAAA,EAC9B;AAEA,MAAI;AACF,UAAM,UAAU,KAAK,MAAM,OAAO;AAClC,QAAI,CAAC,MAAM,QAAQ,OAAO,EAAG,OAAM,IAAI,MAAM,cAAc;AAC3D,WAAO;AAAA,EACT,QAAQ;AACN,UAAM,IAAI;AAAA,MACR,iCAAiC,SAAS,IAAI;AAAA,YAAuC,SAAS,MAAM,GAAG,GAAG,CAAC;AAAA,IAC7G;AAAA,EACF;AACF;;;ACjFA,SAAS,gBAA8D;AACvE,SAAS,aAAAC,kBAAiB;AAC1B,SAAS,QAAAC,OAAM,WAAAC,gBAAe;AAW9B,IAAI;AAEJ,eAAsB,cAAc,QAAoC;AACtE,MAAI,CAAC,WAAW,CAAC,QAAQ,YAAY,GAAG;AACtC,cAAU,MAAM,SAAS,OAAO;AAAA,MAC9B,UAAU,CAAC;AAAA,IACb,CAAC;AAAA,EACH;AACA,SAAO;AACT;AAEA,eAAsB,eAA8B;AAClD,MAAI,SAAS;AACX,UAAM,QAAQ,MAAM;AACpB,cAAU;AAAA,EACZ;AACF;AAKA,eAAsB,gBACpB,UACA,SACA,SAC6B;AAC7B,QAAM,QAAQ,KAAK,IAAI;AACvB,QAAM,cAA4B,CAAC;AACnC,QAAM,cAAwB,CAAC;AAC/B,MAAI;AACJ,MAAI;AAEJ,MAAI;AACF,UAAM,IAAI,MAAM,cAAc,QAAQ,MAAM;AAC5C,cAAU,MAAM,EAAE,WAAW;AAAA,MAC3B,UAAU,EAAE,OAAO,MAAM,QAAQ,IAAI;AAAA,IACvC,CAAC;AACD,WAAO,MAAM,QAAQ,QAAQ;AAG7B,SAAK,GAAG,WAAW,CAAC,QAAQ;AAC1B,kBAAY,KAAK,IAAI,IAAI,KAAK,CAAC,KAAK,IAAI,KAAK,CAAC,EAAE;AAAA,IAClD,CAAC;AAED,SAAK,GAAG,aAAa,CAAC,UAAU;AAC9B,kBAAY,KAAK,WAAW,MAAM,OAAO,EAAE;AAAA,IAC7C,CAAC;AAED,UAAM,UAAU,QAAQ,WAAW;AAEnC,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,YAAM,SAAS,QAAQ,CAAC;AACxB,YAAM,aAAyB;AAAA,QAC7B,MAAM,IAAI;AAAA,QACV,aAAa,OAAO;AAAA,QACpB,QAAQ;AAAA,MACV;AAEA,UAAI;AACF,cAAM,cAAc,MAAM,QAAQ,QAAQ,SAAS,OAAO;AAC1D,mBAAW,SAAS;AAAA,MACtB,SAAS,OAAO;AACd,mBAAW,SAAS;AACpB,mBAAW,QACT,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAGvD,cAAM,iBAAiB,GAAGC,SAAQ,SAAS,IAAI,CAAC,QAAQ,IAAI,CAAC;AAC7D,cAAM,iBAAiBF,MAAK,QAAQ,eAAe,cAAc;AACjE,QAAAD,WAAUE,SAAQ,cAAc,GAAG,EAAE,WAAW,KAAK,CAAC;AAEtD,YAAI;AACF,gBAAM,KAAK,WAAW,EAAE,MAAM,eAAe,CAAC;AAC9C,qBAAW,iBAAiB;AAAA,QAC9B,QAAQ;AAAA,QAER;AAEA,oBAAY,KAAK,UAAU;AAG3B,eAAO;AAAA,UACL;AAAA,UACA,QAAQ;AAAA,UACR;AAAA,UACA,YAAY,IAAI;AAAA,UAChB,UAAU,OAAO;AAAA,UACjB,QAAQ,WAAW;AAAA,UACnB,gBAAgB,WAAW;AAAA,UAC3B,aAAa,YAAY;AAAA,YACvB,CAAC,MAAM,EAAE,SAAS,SAAS,KAAK,EAAE,SAAS,WAAW;AAAA,UACxD;AAAA,UACA,UAAU,KAAK,IAAI,IAAI;AAAA,QACzB;AAAA,MACF;AAEA,kBAAY,KAAK,UAAU;AAAA,IAC7B;AAEA,WAAO;AAAA,MACL;AAAA,MACA,QAAQ;AAAA,MACR;AAAA,MACA,aAAa,YAAY;AAAA,QACvB,CAAC,MAAM,EAAE,SAAS,SAAS,KAAK,EAAE,SAAS,WAAW;AAAA,MACxD;AAAA,MACA,UAAU,KAAK,IAAI,IAAI;AAAA,IACzB;AAAA,EACF,UAAE;AACA,QAAI,SAAS;AACX,YAAM,QAAQ,MAAM,EAAE,MAAM,MAAM;AAAA,MAAC,CAAC;AAAA,IACtC;AAAA,EACF;AACF;AAEA,eAAe,cACb,MACA,QACA,SACA,SACe;AACf,UAAQ,OAAO,MAAM;AAAA,IACnB,KAAK,YAAY;AACf,YAAM,MAAM,OAAO,KAAK,WAAW,MAAM,IACrC,OAAO,MACP,GAAG,OAAO,GAAG,OAAO,GAAG;AAC3B,YAAM,KAAK,KAAK,KAAK,EAAE,WAAW,oBAAoB,QAAQ,CAAC;AAC/D;AAAA,IACF;AAAA,IAEA,KAAK,SAAS;AACZ,YAAM,UAAU,eAAe,MAAM,OAAO,QAAS;AACrD,YAAM,QAAQ,MAAM,EAAE,QAAQ,CAAC;AAC/B;AAAA,IACF;AAAA,IAEA,KAAK,QAAQ;AACX,YAAM,UAAU,eAAe,MAAM,OAAO,QAAS;AACrD,YAAM,QAAQ,KAAK,OAAO,OAAQ,EAAE,QAAQ,CAAC;AAC7C;AAAA,IACF;AAAA,IAEA,KAAK,UAAU;AACb,YAAM,UAAU,eAAe,MAAM,OAAO,QAAS;AACrD,YAAM,QAAQ,aAAa,OAAO,OAAQ,EAAE,QAAQ,CAAC;AACrD;AAAA,IACF;AAAA,IAEA,KAAK,QAAQ;AACX,UAAI,OAAO,UAAU,MAAM,OAAO,GAAG;AACnC,cAAM,KAAK,eAAe,SAAS,OAAO,QAAQ,CAAC;AAAA,MACrD,WAAW,OAAO,UAAU;AAC1B,cAAM,UAAU,eAAe,MAAM,OAAO,QAAQ;AACpD,cAAM,QAAQ,QAAQ,EAAE,OAAO,WAAW,QAAQ,CAAC;AAAA,MACrD,OAAO;AACL,cAAM,KAAK,eAAe,GAAI;AAAA,MAChC;AACA;AAAA,IACF;AAAA,IAEA,KAAK,UAAU;AACb,YAAM,UAAU,eAAe,MAAM,OAAO,QAAS;AACrD,YAAM,QAAQ,QAAQ,EAAE,OAAO,WAAW,QAAQ,CAAC;AACnD,UAAI,OAAO,OAAO;AAChB,cAAM,OAAO,MAAM,QAAQ,YAAY,EAAE,QAAQ,CAAC;AAClD,YAAI,CAAC,MAAM,SAAS,OAAO,KAAK,GAAG;AACjC,gBAAM,IAAI;AAAA,YACR,kBAAkB,OAAO,KAAK,cAAc,MAAM,MAAM,GAAG,GAAG,CAAC;AAAA,UACjE;AAAA,QACF;AAAA,MACF;AACA;AAAA,IACF;AAAA,IAEA,KAAK,YAAY;AACf,YAAM,KAAK,SAAS,MAAM,OAAO,GAAI;AACrC;AAAA,IACF;AAAA,IAEA;AACE,YAAM,IAAI,MAAM,wBAAyB,OAA4B,IAAI,EAAE;AAAA,EAC/E;AACF;AAOA,SAAS,eAAe,MAAY,UAAkB;AAEpD,MAAI,SAAS,WAAW,UAAU,KAAK,SAAS,WAAW,UAAU,GAAG;AACtE,WAAO,KAAK,QAAQ,MAAM;AAAA,EAC5B;AAGA,QAAM,gBAAgB,SAAS,MAAM,yCAAyC;AAC9E,MAAI,eAAe;AACjB,UAAM,OAAO,cAAc,CAAC,IAAI,EAAE,MAAM,cAAc,CAAC,EAAE,IAAI;AAC7D,WAAO,KAAK,UAAU,cAAc,CAAC,GAAuC,IAAI,EAAE,MAAM;AAAA,EAC1F;AAGA,QAAM,YAAY,SAAS;AAAA,IACzB;AAAA,EACF;AACA,MAAI,WAAW;AACb,WAAO,KAAK,UAAU,UAAU,CAAC,GAAuC;AAAA,MACtE,MAAM,UAAU,CAAC;AAAA,IACnB,CAAC,EAAE,MAAM;AAAA,EACX;AAGA,MAAI,SAAS,WAAW,OAAO,GAAG;AAChC,UAAM,YAAY,SAAS,MAAM,CAAC;AAClC,WAAO,KAAK,UAAU,WAAW,SAAS,CAAC,EAAE,MAAM;AAAA,EACrD;AAGA,QAAM,aAAa,SAAS,MAAM,wBAAwB;AAC1D,MAAI,YAAY;AACd,WAAO,KAAK,UAAU,IAAI,OAAO,WAAW,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,EAAE,MAAM;AAAA,EACxE;AAGA,QAAM,iBAAiB,SAAS,MAAM,qCAAqC;AAC3E,MAAI,gBAAgB;AAClB,WAAO,KAAK,UAAU,IAAI,OAAO,eAAe,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,EAAE,MAAM;AAAA,EAChF;AAGA,MAAI,SAAS,WAAW,cAAc,GAAG;AACvC,WAAO,KAAK,iBAAiB,SAAS,MAAM,EAAE,CAAC,EAAE,MAAM;AAAA,EACzD;AAGA,MAAI,SAAS,WAAW,QAAQ,GAAG;AACjC,WAAO,KAAK,WAAW,SAAS,MAAM,CAAC,CAAC,EAAE,MAAM;AAAA,EAClD;AAGA,MAAI,SAAS,WAAW,SAAS,GAAG;AAClC,WAAO,KAAK,YAAY,SAAS,MAAM,CAAC,CAAC,EAAE,MAAM;AAAA,EACnD;AAGA,SAAO,KAAK,QAAQ,QAAQ,EAAE,MAAM;AACtC;AAMA,SAAS,WAAW,MAA+B;AACjD,QAAM,QAAQ,KAAK,MAAM,wBAAwB;AACjD,MAAI,OAAO;AACT,WAAO,IAAI,OAAO,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;AAAA,EACtC;AACA,SAAO;AACT;AAEA,SAASC,SAAQ,MAAsB;AACrC,SAAO,KACJ,YAAY,EACZ,QAAQ,eAAe,GAAG,EAC1B,QAAQ,UAAU,EAAE;AACzB;;;ACvRA,SAAS,OAAO,gBAAmC;AAEnD,IAAI;AAKJ,eAAsB,cAAc,KAA+B;AACjE,MAAI;AACF,UAAM,WAAW,MAAM,MAAM,KAAK;AAAA,MAChC,QAAQ,YAAY,QAAQ,GAAI;AAAA,MAChC,UAAU;AAAA,IACZ,CAAC;AAED,WAAO,SAAS,SAAS;AAAA,EAC3B,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAKA,eAAsB,cACpB,KACA,YAAoB,KACF;AAClB,QAAM,QAAQ,KAAK,IAAI;AACvB,SAAO,KAAK,IAAI,IAAI,QAAQ,WAAW;AACrC,QAAI,MAAM,cAAc,GAAG,EAAG,QAAO;AACrC,UAAM,IAAI,QAAQ,CAAC,MAAM,WAAW,GAAG,GAAI,CAAC;AAAA,EAC9C;AACA,SAAO;AACT;AAKO,SAAS,eAAe,SAAiB,KAA2B;AAEzE,oBAAkB,GAAI;AAEtB,QAAM,CAAC,KAAK,GAAG,IAAI,IAAI,QAAQ,MAAM,GAAG;AACxC,kBAAgB,MAAM,KAAK,MAAM;AAAA,IAC/B;AAAA,IACA,OAAO;AAAA,IACP,KAAK,EAAE,GAAG,QAAQ,KAAK,MAAM,OAAO;AAAA,IACpC,OAAO;AAAA,EACT,CAAC;AAED,gBAAc,QAAQ,GAAG,QAAQ,MAAM;AAAA,EAAC,CAAC;AACzC,gBAAc,QAAQ,GAAG,QAAQ,MAAM;AAAA,EAAC,CAAC;AAEzC,gBAAc,GAAG,QAAQ,MAAM;AAC7B,oBAAgB;AAAA,EAClB,CAAC;AAED,SAAO;AACT;AAKO,SAAS,gBAAsB;AACpC,MAAI,iBAAiB,CAAC,cAAc,QAAQ;AAC1C,QAAI;AACF,oBAAc,KAAK,SAAS;AAAA,IAC9B,QAAQ;AAAA,IAER;AACA,oBAAgB;AAAA,EAClB;AAEA,oBAAkB,GAAI;AACxB;AAKA,SAAS,kBAAkB,MAAoB;AAC7C,MAAI;AACF,UAAM,OAAO,SAAS,YAAY,IAAI,gBAAgB;AAAA,MACpD,UAAU;AAAA,IACZ,CAAC,EAAE,KAAK;AACR,QAAI,MAAM;AACR,iBAAW,OAAO,KAAK,MAAM,IAAI,GAAG;AAClC,YAAI;AACF,kBAAQ,KAAK,SAAS,GAAG,GAAG,SAAS;AAAA,QACvC,QAAQ;AAAA,QAER;AAAA,MACF;AAEA,eAAS,SAAS;AAAA,IACpB;AAAA,EACF,QAAQ;AAAA,EAER;AACF;AAKA,eAAsB,gBACpB,SACA,YACA,MAAc,QAAQ,IAAI,GACR;AAElB,MAAI,MAAM,cAAc,OAAO,GAAG;AAChC,WAAO;AAAA,EACT;AAEA,MAAI,CAAC,YAAY;AACf,UAAM,IAAI;AAAA,MACR,wBAAwB,OAAO;AAAA,IAEjC;AAAA,EACF;AAGA,gBAAc;AACd,QAAM,IAAI,QAAQ,CAAC,MAAM,WAAW,GAAG,GAAI,CAAC;AAE5C,iBAAe,YAAY,GAAG;AAC9B,QAAM,QAAQ,MAAM,cAAc,OAAO;AAEzC,MAAI,CAAC,OAAO;AACV,kBAAc;AACd,UAAM,IAAI;AAAA,MACR,0DAA0D,UAAU;AAAA,IACtE;AAAA,EACF;AAEA,SAAO;AACT;;;AL/HA,SAAS,YAAAC,iBAAgB;AAWzB,eAAsB,gBACpB,QACA,UAAyB,CAAC,GACI;AAC9B,QAAM,QAAQ,KAAK,IAAI;AACvB,QAAM,MAAM,QAAQ,IAAI;AACxB,QAAM,eAAeC,SAAQ,KAAK,OAAO,YAAY;AACrD,QAAM,gBAAgBA,SAAQ,KAAK,WAAW,UAAU;AAGxD,MAAI,YAAY,iBAAiB,YAAY;AAC7C,MAAI,UAAU,WAAW,GAAG;AAC1B,UAAM,IAAI;AAAA,MACR,yBAAyB,OAAO,YAAY;AAAA,IAC9C;AAAA,EACF;AAGA,MAAI,QAAQ,QAAQ;AAClB,UAAM,UAAU,IAAI,OAAO,QAAQ,QAAQ,GAAG;AAC9C,gBAAY,UAAU;AAAA,MACpB,CAACC,OAAM,QAAQ,KAAKA,GAAE,IAAI,KAAK,QAAQ,KAAKA,GAAE,QAAQ,KAAK,QAAQ,KAAKA,GAAE,QAAQ;AAAA,IACpF;AACA,QAAI,UAAU,WAAW,GAAG;AAC1B,YAAM,IAAI,MAAM,8BAA8B,QAAQ,MAAM,GAAG;AAAA,IACjE;AAAA,EACF;AAEA,MAAI,KAAK,SAAS,UAAU,MAAM,YAAY;AAG9C,MAAI,OAAO,OAAO;AAChB,UAAMA,KAAI,QAAQ,kBAAkB,OAAO,KAAK,EAAE;AAClD,QAAI;AACF,MAAAF,UAAS,OAAO,OAAO,EAAE,KAAK,OAAO,OAAO,CAAC;AAC7C,MAAAE,GAAE,QAAQ,gBAAgB;AAAA,IAC5B,SAAS,OAAO;AACd,MAAAA,GAAE,KAAK,cAAc;AACrB,YAAM;AAAA,IACR;AAAA,EACF;AAGA,QAAM,IAAI,QAAQ,sBAAsB,OAAO,OAAO,KAAK;AAC3D,MAAI;AACF,UAAM,gBAAgB,OAAO,SAAS,OAAO,YAAY,GAAG;AAC5D,MAAE,QAAQ,mBAAmB,OAAO,OAAO,EAAE;AAAA,EAC/C,SAAS,OAAO;AACd,MAAE,KAAK,sBAAsB;AAC7B,UAAM;AAAA,EACR;AAGA,QAAM,UAAgC,CAAC;AACvC,QAAM,QAAQ,QAAQ,SAAS,OAAO;AAEtC,MAAI,QAAQ,qBAAqB;AAEjC,WAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,UAAM,WAAW,UAAU,CAAC;AAC5B,UAAM,SAAS,IAAI,IAAI,CAAC,IAAI,UAAU,MAAM;AAE5C,QAAI;AAEF,YAAM,UAAU,MAAM,kBAAkB,UAAU,OAAO,SAAS,KAAK;AAGvE,YAAM,SAAS,MAAM,gBAAgB,UAAU,SAAS;AAAA,QACtD,SAAS,OAAO;AAAA,QAChB,QAAQ,QAAQ;AAAA,QAChB;AAAA,MACF,CAAC;AAED,cAAQ,KAAK,MAAM;AACnB,UAAI,SAAS,GAAG,MAAM,IAAI,SAAS,QAAQ,IAAI,SAAS,IAAI,IAAI,OAAO,MAAM;AAE7E,UAAI,CAAC,OAAO,UAAU,OAAO,QAAQ;AACnC,YAAI,IAAI,SAAS,OAAO,OAAO,MAAM,GAAG,GAAG,CAAC,EAAE;AAAA,MAChD;AAAA,IACF,SAAS,OAAO;AACd,YAAM,WAAW,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AACtE,cAAQ,KAAK;AAAA,QACX;AAAA,QACA,QAAQ;AAAA,QACR,aAAa,CAAC;AAAA,QACd,aAAa,CAAC;AAAA,QACd,QAAQ;AAAA,QACR,UAAU;AAAA,MACZ,CAAC;AACD,UAAI,SAAS,GAAG,MAAM,IAAI,SAAS,QAAQ,IAAI,SAAS,IAAI,IAAI,KAAK;AACrE,UAAI,IAAI,SAAS,SAAS,MAAM,GAAG,GAAG,CAAC,EAAE;AAAA,IAC3C;AAAA,EACF;AAGA,QAAM,aAAa;AAEnB,QAAM,UAA+B;AAAA,IACnC,OAAO,QAAQ;AAAA,IACf,QAAQ,QAAQ,OAAO,CAAC,MAAM,EAAE,MAAM,EAAE;AAAA,IACxC,QAAQ,QAAQ,OAAO,CAAC,MAAM,CAAC,EAAE,MAAM,EAAE;AAAA,IACzC;AAAA,IACA,UAAU,KAAK,IAAI,IAAI;AAAA,EACzB;AAEA,SAAO;AACT;AAKO,SAAS,aAAa,SAAoC;AAC/D,QAAM,EAAE,OAAO,QAAQ,QAAQ,SAAS,IAAI;AAE5C,MAAI,QAAQ,SAAS;AAErB,MAAI,WAAW,GAAG;AAChB,QAAI,QAAQ,OAAO,KAAK,oBAAoB;AAAA,EAC9C,OAAO;AACL,QAAI,KAAK,GAAG,MAAM,IAAI,KAAK,mBAAmB;AAE9C,QAAI,QAAQ,WAAW;AACvB,eAAW,UAAU,QAAQ,QAAQ,OAAO,CAAC,MAAM,CAAC,EAAE,MAAM,GAAG;AAC7D,cAAQ,IAAI,EAAE;AACd,UAAI,KAAK,GAAG,OAAO,SAAS,QAAQ,IAAI,OAAO,SAAS,IAAI,EAAE;AAC9D,UAAI,OAAO,YAAY;AACrB,YAAI,IAAI,UAAU,OAAO,UAAU,KAAK,OAAO,QAAQ,EAAE;AAAA,MAC3D;AACA,UAAI,OAAO,QAAQ;AACjB,YAAI,IAAI,UAAU,OAAO,OAAO,MAAM,GAAG,GAAG,CAAC,EAAE;AAAA,MACjD;AACA,UAAI,OAAO,gBAAgB;AACzB,YAAI,IAAI,iBAAiB,OAAO,cAAc,EAAE;AAAA,MAClD;AAAA,IACF;AAAA,EACF;AAEA,MAAI,IAAI;AAAA,aAAgB,WAAW,KAAM,QAAQ,CAAC,CAAC,GAAG;AACxD;AAKO,SAAS,oBAAoB,SAAsC;AACxE,QAAM,QAAkB,CAAC;AACzB,QAAM;AAAA,IACJ,4BAA4B,QAAQ,MAAM,IAAI,QAAQ,KAAK;AAAA;AAAA,EAC7D;AAEA,QAAM,WAAW,QAAQ,QAAQ,OAAO,CAAC,MAAM,CAAC,EAAE,MAAM;AACxD,MAAI,SAAS,WAAW,EAAG,QAAO,MAAM,KAAK,IAAI;AAEjD,QAAM,KAAK,OAAO,SAAS,MAAM;AAAA,CAAsB;AAEvD,aAAW,UAAU,UAAU;AAC7B,UAAM,KAAK,QAAQ,OAAO,SAAS,QAAQ,EAAE;AAC7C,UAAM,KAAK,iBAAiB,OAAO,SAAS,IAAI,EAAE;AAElD,QAAI,OAAO,YAAY;AACrB,YAAM,OAAO,OAAO,SAAS,MAAM,OAAO,aAAa,CAAC;AACxD,YAAM,KAAK,oBAAoB,OAAO,UAAU,OAAO,IAAI,EAAE;AAAA,IAC/D;AAEA,QAAI,OAAO,UAAU;AACnB,YAAM,KAAK,iBAAiB,OAAO,QAAQ,EAAE;AAAA,IAC/C;AACA,QAAI,OAAO,QAAQ;AACjB,YAAM,KAAK,eAAe,OAAO,MAAM,EAAE;AAAA,IAC3C;AAEA,QAAI,OAAO,YAAY,SAAS,GAAG;AACjC,YAAM,KAAK,cAAc;AACzB,iBAAW,YAAY,OAAO,YAAY,MAAM,GAAG,CAAC,GAAG;AACrD,cAAM,KAAK,KAAK,QAAQ,EAAE;AAAA,MAC5B;AAAA,IACF;AAEA,UAAM,KAAK,EAAE;AAAA,EACf;AAEA,SAAO,MAAM,KAAK,IAAI;AACxB;;;AMnMA,eAAsB,cAAc,SAGlB;AAChB,QAAM,MAAM,QAAQ,IAAI;AAExB,QAAM,SAAS,MAAM,WAAW,GAAG;AAEnC,MAAI;AACF,UAAM,UAAU,MAAM,gBAAgB,QAAQ;AAAA,MAC5C,QAAQ,QAAQ;AAAA,MAChB,QAAQ,QAAQ;AAAA,IAClB,CAAC;AAED,iBAAa,OAAO;AAEpB,QAAI,QAAQ,SAAS,GAAG;AACtB,cAAQ,KAAK,CAAC;AAAA,IAChB;AAAA,EACF,SAAS,OAAO;AACd,QAAI,KAAK,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAC/D,YAAQ,KAAK,CAAC;AAAA,EAChB,UAAE;AACA,kBAAc;AAAA,EAChB;AACF;;;AC9BA,SAAS,iBAAAC,gBAAe,aAAAC,kBAAiB;AACzC,SAAS,QAAAC,aAAY;;;ACDrB,SAAS,SAAAC,QAAO,iBAAiB;AACjC,SAAS,iBAAAC,sBAAqB;AAC9B,SAAS,WAAAC,UAAS,QAAAC,aAAY;AAe9B,eAAsB,kBACpB,SAC+C;AAC/C,QAAM,EAAE,IAAI,IAAI;AAEhB,QAAM,SAAS,kBAAkB,OAAO;AAGxC,QAAM,aAAaC,MAAK,KAAK,WAAW,gBAAgB;AACxD,EAAAC,eAAc,YAAY,QAAQ,OAAO;AAEzC,MAAI,CAAC,sBAAsB,GAAG;AAC5B,UAAM,IAAI;AAAA,MACR;AAAA,IAEF;AAAA,EACF;AAEA,SAAO,aAAa,QAAQ,GAAG;AACjC;AAEA,SAAS,kBAAkB,SAAqC;AAC9D,QAAM,EAAE,cAAc,eAAe,WAAW,IAAI,IAAI;AACxD,QAAM,gBAAgBC,SAAQ,KAAK,YAAY;AAE/C,QAAM,QAAkB,CAAC;AAEzB,QAAM,KAAK,mCAA8B,SAAS,EAAE;AACpD,QAAM,KAAK,EAAE;AACb,QAAM;AAAA,IACJ;AAAA,EACF;AACA,QAAM,KAAK,EAAE;AACb,QAAM,KAAK,UAAU;AACrB,QAAM,KAAK,gEAAgE;AAC3E,QAAM;AAAA,IACJ;AAAA,EACF;AACA,QAAM,KAAK,qDAAqD;AAChE,QAAM,KAAK,sCAAsC;AACjD,QAAM,KAAK,2CAA2C;AACtD,QAAM,KAAK,wEAAwE;AACnF,QAAM,KAAK,EAAE;AACb,QAAM,KAAK,2BAA2B,aAAa,EAAE;AACrD,QAAM,KAAK,EAAE;AAEb,MAAI,cAAc,GAAG;AACnB,UAAM,KAAK,SAAS;AACpB,UAAM;AAAA,MACJ;AAAA,IACF;AACA,UAAM;AAAA,MACJ;AAAA,IACF;AAAA,EACF,WAAW,eAAe;AACxB,UAAM,KAAK,kCAAkC;AAC7C,UAAM,KAAK,EAAE;AACb,UAAM,KAAK,aAAa;AACxB,UAAM,KAAK,EAAE;AACb,UAAM,KAAK,SAAS;AACpB,UAAM;AAAA,MACJ;AAAA,IACF;AACA,UAAM;AAAA,MACJ;AAAA,IACF;AACA,UAAM,KAAK,sDAAsD;AAAA,EACnE;AAEA,SAAO,MAAM,KAAK,IAAI;AACxB;AAEA,SAAS,wBAAiC;AACxC,MAAI;AACF,UAAM,SAAS,UAAU,SAAS,CAAC,QAAQ,GAAG,EAAE,UAAU,QAAQ,CAAC;AACnE,WAAO,OAAO,WAAW;AAAA,EAC3B,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAKA,eAAe,aACb,QACA,KAC+C;AAC/C,QAAM,IAAI,QAAQ,yBAAyB;AAE3C,SAAO,IAAI,QAAQ,CAACA,aAAY;AAC9B,UAAM,SAAmB,CAAC;AAC1B,UAAM,YAAsB,CAAC;AAE7B,UAAM,OAAOC;AAAA,MACX;AAAA,MACA;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,MACA;AAAA,QACE;AAAA,QACA,KAAK,EAAE,GAAG,QAAQ,IAAI;AAAA,QACtB,OAAO,CAAC,UAAU,QAAQ,MAAM;AAAA,MAClC;AAAA,IACF;AAEA,SAAK,QAAQ,GAAG,QAAQ,CAAC,SAAiB;AACxC,aAAO,KAAK,KAAK,SAAS,CAAC;AAAA,IAC7B,CAAC;AAED,SAAK,QAAQ,GAAG,QAAQ,CAAC,SAAiB;AACxC,gBAAU,KAAK,KAAK,SAAS,CAAC;AAAA,IAChC,CAAC;AAGD,UAAM,UAAU,WAAW,MAAM;AAC/B,WAAK,KAAK,SAAS;AACnB,QAAE,KAAK,iCAAiC;AACxC,MAAAD,SAAQ;AAAA,QACN,SAAS;AAAA,QACT,QAAQ,OAAO,KAAK,EAAE,IAAI;AAAA,MAC5B,CAAC;AAAA,IACH,GAAG,GAAM;AAET,SAAK,GAAG,SAAS,CAAC,SAAS;AACzB,mBAAa,OAAO;AACpB,YAAM,SAAS,OAAO,KAAK,EAAE;AAE7B,UAAI,SAAS,GAAG;AACd,UAAE,QAAQ,wBAAwB;AAClC,QAAAA,SAAQ,EAAE,SAAS,MAAM,OAAO,CAAC;AAAA,MACnC,OAAO;AAEL,UAAE,QAAQ,uCAAuC,OAAO,GAAG;AAC3D,QAAAA,SAAQ,EAAE,SAAS,SAAS,GAAG,QAAQ,UAAU,UAAU,KAAK,EAAE,EAAE,CAAC;AAAA,MACvE;AAAA,IACF,CAAC;AAED,SAAK,GAAG,SAAS,CAAC,UAAU;AAC1B,mBAAa,OAAO;AACpB,QAAE,KAAK,oBAAoB;AAC3B,MAAAA,SAAQ;AAAA,QACN,SAAS;AAAA,QACT,QAAQ,MAAM;AAAA,MAChB,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AACH;;;AC7JO,IAAM,iBAAN,MAAqB;AAAA,EAClB,UAA6B,CAAC;AAAA,EAC9B;AAAA,EAER,YAAY,wBAAgC,GAAG;AAC7C,SAAK,wBAAwB;AAAA,EAC/B;AAAA,EAEA,OAAO,WAAmB,SAAoC;AAC5D,SAAK,QAAQ,KAAK;AAAA,MAChB;AAAA,MACA,QAAQ,QAAQ;AAAA,MAChB,QAAQ,QAAQ;AAAA,MAChB,kBAAkB,QAAQ,QACvB,OAAO,CAAC,MAAM,CAAC,EAAE,MAAM,EACvB,IAAI,CAAC,MAAM,EAAE,SAAS,QAAQ;AAAA,IACnC,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,aAAiC;AAC/B,QAAI,KAAK,QAAQ,SAAS,EAAG,QAAO;AAGpC,UAAM,SAAS,KAAK,QAAQ,MAAM,CAAC,KAAK,qBAAqB;AAC7D,QAAI,OAAO,UAAU,KAAK,uBAAuB;AAC/C,YAAM,aAAa,OAAO,IAAI,CAAC,MAAM,EAAE,MAAM;AAC7C,YAAM,UAAU,WAAW,MAAM,CAAC,MAAM,MAAM,WAAW,CAAC,CAAC;AAC3D,UAAI,WAAW,WAAW,CAAC,IAAI,GAAG;AAChC,eAAO,gBAAgB,WAAW,CAAC,CAAC,oCAAoC,KAAK,qBAAqB;AAAA,MACpG;AAAA,IACF;AAGA,UAAM,YAAY,KAAK,IAAI,GAAG,KAAK,QAAQ,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC;AAC/D,UAAM,UAAU,KAAK,QAAQ,KAAK,QAAQ,SAAS,CAAC;AACpD,UAAM,WAAW,KAAK,QAAQ,KAAK,QAAQ,SAAS,CAAC;AACrD,QACE,QAAQ,SAAS,SAAS,UAC1B,QAAQ,SAAS,YAAY,GAC7B;AACA,aAAO,wBAAwB,QAAQ,MAAM,kBAAkB,SAAS,MAAM,cAAc,SAAS;AAAA,IACvG;AAGA,QAAI,KAAK,QAAQ,UAAU,GAAG;AAC5B,YAAM,QAAQ,KAAK,QAAQ,MAAM,EAAE;AACnC,YAAM,WAAW,KAAK,UAAU,MAAM,CAAC,EAAE,gBAAgB;AACzD,YAAM,WAAW,KAAK,UAAU,MAAM,CAAC,EAAE,gBAAgB;AACzD,YAAM,WAAW,KAAK,UAAU,MAAM,CAAC,EAAE,gBAAgB;AACzD,YAAM,WAAW,KAAK,UAAU,MAAM,CAAC,EAAE,gBAAgB;AAEzD,UAAI,aAAa,YAAY,aAAa,YAAY,aAAa,UAAU;AAC3E,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,oBAA8B;AAC5B,QAAI,KAAK,QAAQ,SAAS,EAAG,QAAO,CAAC;AAErC,UAAM,iBAAiB,KAAK,QAAQ,MAAM,EAAE;AAC5C,UAAM,eAAe,eAAe,IAAI,CAAC,MAAM,IAAI,IAAI,EAAE,gBAAgB,CAAC;AAG1E,UAAM,WAAW,aAAa,CAAC;AAC/B,WAAO,CAAC,GAAG,QAAQ,EAAE;AAAA,MAAO,CAAC,MAC3B,aAAa,MAAM,CAAC,QAAQ,IAAI,IAAI,CAAC,CAAC;AAAA,IACxC;AAAA,EACF;AAAA,EAEA,aAAgC;AAC9B,WAAO,CAAC,GAAG,KAAK,OAAO;AAAA,EACzB;AACF;;;AFnEA,eAAsB,aACpB,QACA,SACqB;AACrB,QAAM,MAAM,QAAQ,IAAI;AACxB,QAAM,YAAYE,MAAK,KAAK,SAAS;AACrC,EAAAC,WAAU,WAAW,EAAE,WAAW,KAAK,CAAC;AAExC,QAAM,iBAAiB,IAAI,eAAe,CAAC;AAC3C,MAAI;AACJ,MAAI;AAEJ,MAAI;AAAA,IACF,4BAA4B,QAAQ,aAAa,wBAAwB,QAAQ,OAAO;AAAA,EAC1F;AACA,UAAQ,IAAI,EAAE;AAEd,MAAI;AACF,aAAS,YAAY,GAAG,aAAa,QAAQ,eAAe,aAAa;AACvE,UAAI,QAAQ,0BAAgB,SAAS,eAAK;AAG1C,YAAM,cAAc,MAAM,kBAAkB;AAAA,QAC1C,OAAO,QAAQ;AAAA,QACf;AAAA,QACA,cAAc,OAAO;AAAA,QACrB,eAAe;AAAA,QACf;AAAA,MACF,CAAC;AAGD,MAAAC;AAAA,QACEF,MAAK,WAAW,gBAAgB,SAAS,KAAK;AAAA,QAC9C,YAAY;AAAA,QACZ;AAAA,MACF;AAEA,UAAI,CAAC,YAAY,SAAS;AACxB,YAAI,KAAK,uDAAuD,SAAS,GAAG;AAAA,MAC9E;AAGA,UAAI,KAAK,wBAAwB;AAEjC,UAAI;AACF,sBAAc,MAAM,gBAAgB,QAAQ;AAAA,UAC1C,OAAO,QAAQ;AAAA,QACjB,CAAC;AAAA,MACH,SAAS,OAAO;AACd,YAAI;AAAA,UACF,wBAAwB,iBAAiB,QAAQ,MAAM,UAAU,KAAK;AAAA,QACxE;AAEA;AAAA,MACF;AAGA,YAAM,EAAE,OAAO,QAAQ,OAAO,IAAI;AAClC,UAAI,WAAW,GAAG;AAChB,YAAI,QAAQ,OAAO,KAAK,qBAAqB;AAC7C,qBAAa,WAAW;AACxB,eAAO;AAAA,UACL,SAAS;AAAA,UACT,YAAY;AAAA,UACZ,cAAc;AAAA,QAChB;AAAA,MACF;AAEA,UAAI,KAAK,GAAG,MAAM,IAAI,KAAK,aAAa,MAAM,WAAW;AAGzD,qBAAe,OAAO,WAAW,WAAW;AAC5C,YAAM,aAAa,eAAe,WAAW;AAE7C,UAAI,YAAY;AACd,YAAI,KAAK,oBAAoB,UAAU,EAAE;AAEzC,cAAM,iBAAiB,eAAe,kBAAkB;AACxD,YAAI,eAAe,SAAS,GAAG;AAC7B,cAAI,QAAQ,iCAAiC;AAC7C,qBAAW,KAAK,gBAAgB;AAC9B,gBAAI,IAAI,KAAK,CAAC,EAAE;AAAA,UAClB;AAAA,QACF;AAEA,qBAAa,WAAW;AACxB,eAAO;AAAA,UACL,SAAS;AAAA,UACT,YAAY;AAAA,UACZ,cAAc;AAAA,UACd,eAAe;AAAA,QACjB;AAAA,MACF;AAGA,0BAAoB,oBAAoB,WAAW;AAGnD,MAAAE;AAAA,QACEF,MAAK,WAAW,YAAY,SAAS,KAAK;AAAA,QAC1C;AAAA,QACA;AAAA,MACF;AAEA,UAAI,IAAI,sCAAsC;AAAA,IAChD;AAGA,QAAI,KAAK,+BAA+B,QAAQ,aAAa,GAAG;AAChE,QAAI,aAAa;AACf,mBAAa,WAAW;AAAA,IAC1B;AAEA,WAAO;AAAA,MACL,SAAS;AAAA,MACT,YAAY,QAAQ;AAAA,MACpB,cAAc;AAAA,MACd,eAAe,+BAA+B,QAAQ,aAAa;AAAA,IACrE;AAAA,EACF,UAAE;AACA,UAAM,aAAa;AACnB,kBAAc;AAAA,EAChB;AACF;;;AGlJA,eAAsB,YAAY,SAIhB;AAChB,QAAM,MAAM,QAAQ,IAAI;AACxB,QAAM,SAAS,MAAM,WAAW,GAAG;AAEnC,QAAM,gBAAgB,SAAS,QAAQ,eAAe,EAAE,KAAK,OAAO,MAAM,iBAAiB;AAC3F,QAAM,UAAU,WAAW,QAAQ,OAAO,KAAK,OAAO,MAAM,WAAW;AACvE,QAAM,QAAQ,QAAQ,SAAS,OAAO,MAAM,SAAS,OAAO;AAE5D,MAAI;AACF,UAAM,SAAS,MAAM,aAAa,QAAQ;AAAA,MACxC;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAED,QAAI,OAAO,SAAS;AAClB,UAAI,QAAQ,OAAO;AACnB,UAAI;AAAA,QACF,+BAA+B,OAAO,UAAU,aAAa,OAAO,eAAe,IAAI,KAAK,GAAG;AAAA,MACjG;AAAA,IACF,OAAO;AACL,UAAI,QAAQ,cAAc;AAC1B,UAAI,OAAO,eAAe;AACxB,YAAI,KAAK,OAAO,aAAa;AAAA,MAC/B;AACA,UAAI;AAAA,QACF;AAAA,MACF;AACA,cAAQ,KAAK,CAAC;AAAA,IAChB;AAAA,EACF,SAAS,OAAO;AACd,QAAI,KAAK,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAC/D,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF;;;AtBpCA,IAAM,UAAU,IAAI,QAAQ;AAE5B,QACG,KAAK,QAAQ,EACb;AAAA,EACC;AACF,EACC,QAAQ,OAAO;AAElB,QACG,QAAQ,MAAM,EACd,YAAY,mCAAmC,EAC/C,OAAO,WAAW;AAErB,QACG,QAAQ,MAAM,EACd,YAAY,kDAAkD,EAC9D,SAAS,iBAAiB,uCAAuC,EACjE,OAAO,uBAAuB,qBAAqB,EACnD,OAAO,WAAW;AAErB,QACG,QAAQ,QAAQ,EAChB,YAAY,2CAA2C,EACvD,OAAO,YAAY,sCAAsC,EACzD,OAAO,0BAA0B,qCAAqC,EACtE,OAAO,aAAa;AAEvB,QACG,QAAQ,MAAM,EACd;AAAA,EACC;AACF,EACC;AAAA,EACC;AAAA,EACA;AAAA,EACA;AACF,EACC,OAAO,wBAAwB,2BAA2B,GAAG,EAC7D,OAAO,uBAAuB,+BAA+B,EAC7D,OAAO,WAAW;AAErB,QAAQ,MAAM;","names":["resolve","readFileSync","existsSync","writeFileSync","resolve","join","resolve","existsSync","readFileSync","join","writeFileSync","existsSync","readFileSync","join","resolve","mkdirSync","writeFileSync","dirname","join","resolve","resolve","readdirSync","statSync","join","extname","readFileSync","dirname","readdirSync","join","statSync","extname","mkdirSync","join","dirname","slugify","execSync","resolve","s","writeFileSync","mkdirSync","join","spawn","writeFileSync","resolve","join","join","writeFileSync","resolve","spawn","join","mkdirSync","writeFileSync"]}